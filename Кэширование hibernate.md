---
tags: ORM
---
[Hibernate. 75. Second Level Cache. Конфигурация - YouTube](https://youtu.be/IibMRVqxHLo)
Кеширование – один из способов оптимизации работы приложения, ключевой задачей которого является **уменьшить количество прямых обращений к БД.**

## Кэш первого уровня: Session / EntityManager.

Кэшем первого уровня в Hibernate считается СЕССИЯ (либо EntityManager — аналог сессии в JPA). Перед тем, как отправить объект в БД, сессия обязательно хранит, кэширует объект за счёт своих ресурсов.

Session – это обёртка вокруг подключения к БД с помощью JDBC, используется один раз.

	Включать в настройках кэширование не нужно, так как, это даже не кэш, а одно название — так по умолчанию работает Hibernate под капотом.

Hibernate хранит отслеживаемые сущности в Map, ключами которой являются id сущностей, а значениями — сами объекты-сущности.

	Если извлекаем из базы сущность по id с помощью EntityManager.find(), то сущность помещается в Map и хранится там до закрытия сессии. И при повторном find() SQL-команда select в базе данных выполнена не будет. Hibernate возьмет эту сущность из Map — карты отслеживаемых сущностей.

![[Кэширование hibernate.png|350]]

## Кэш второго уровня — общий кэш всех сессий SessionFactory (фабрика сессий).
 Кэш второго уровня — это прослойка, общая для всех сессий. То есть одна сессия извлекла сущность, а другая может получить к этой сущности потом доступ. Очевидно, что с такой прослойкой есть проблема — данные могут устареть: в базе данные одни, а в кэше второго уровня — другие.
[[Провайдеры кэша второго уровня Hibernate]]
## Кэш запросов
В Hibernate предусмотрен кэш для запросов, и он интегрирован с кэшем второго уровня.

Это требует двух дополнительных физических мест для хранения кэшированных запросов и временных меток для обновления таблицы БД. Этот вид кэширования эффективен только для часто используемых запросов с одинаковыми параметрами.

**Важно**: хранит результат запроса, причём ключом является сам запрос и те параметры, которые были переданы в запросе. Хитро устроен: сохраняет не объекты целиком, а их id -шники.

## Как работать с кэшем второго уровня
Если кэш первого уровня привязан к **объекту сессии**, то кэш второго уровня привязан к объекту – **фабрике сессий** (Session Factory object) => видимость этого кэша гораздо шире.

Тут будет выполнено 2 запроса в базу, т.к. по умолчанию кэш второго уровня отключен →
![[Пример на кэш 2 уровня.png|400]]
Для включения необходимо добавить следующие строки в конфиг файле JPA (persistence.xml):
![[Настройки для включение кэша 2 уровня.png]]
	Обратите внимание на первую строчку. Hibernate сам не реализует кеширование как таковое. А лишь предоставляет структуру для его реализации, поэтому подключить можно любую реализацию, которая соответствует спецификации ORM фреймворка. Из популярных реализаций можно выделить: **EHCache**, OSCache, SwarmCache, JBoss TreeCache.

Также понадобится отдельно настроить и саму реализацию кэша. В случае с провайдером кэширования **EHCache** это нужно сделать в файле ehcache.xml Еще нужно указать самому hibernate, что именно кэшировать. Это легко можно сделать с помощью аннотаций, например так →
![[Аннотации для кеширования.png|400]]
Только после всех этих манипуляций кэш второго уровня будет включен и в примере выше будет выполнен только 1 запрос в базу.

**Важно!** Hibernate НЕ хранит объекты классов, а хранит информацию в виде массивов строк, чисел и т. д. И идентификатор объекта выступает указателем на эту информацию.

Концептуально это нечто вроде Map, в которой id объекта — ключ, а массивы данных — значение.

>[!note]+ Кэширование зависимостей
>
>Зависимости класса по умолчанию также не кэшируются. Например, если рассмотреть класс выше — SharedDoc, то при выборке коллекция users будет доставаться из БД, а не из кэша второго уровня. Если нужно кэшировать и зависимости, то класс должен выглядеть так → ![[Кэширование зависимостей hibernate.png|400]]


## Стратегии кэшировани
Проблема заключается в том, что кэш второго уровня доступен из нескольких сессий сразу и несколько потоков программы могут одновременно в разных транзакциях работать с одним и тем же объектом.

Следовательно, надо как-то обеспечивать их одинаковым представлением этого объекта.

В Hibernate существует четыре стратегии одновременного доступа к объектам в кэше:
- Read-only (только чтение)
- Read-write (чтение-запись)
- Nonstrict-read-write (не строгое чтение-запись) ****
- Transactional (транзакционное)

| Стратегия                                                                 | Описание                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|---------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| read-only для Entity, которые никогда не меняются                         | Используется только для сущностей, **которые никогда не изменяются** (будет выброшено исключение, если попытаться обновить такую сущность). Очень просто и производительно. Подходит для некоторых статических данных, которые не меняются.                                                                                                                                                                                                                          |
| read-write строгая согласованность с использованием мягких блокировок     | Эта стратегия гарантирует строгую согласованность, которую она достигает, используя «мягкие» блокировки: когда обновляется кэшированная сущность, на нее накладывается мягкая блокировка, которая снимается после коммита транзакции. Все параллельные транзакции, которые пытаются получить доступ к записям в кэше с наложенной мягкой блокировкой, не смогут их прочитать или записать и отправят запрос в БД. Ehcache использует эту стратегию по умолчанию. |
| nonstrict read-write (нестрогое) строгая согласованность НЕ гарантируется | Кэш обновляется после совершения транзакции, которая изменила данные в БД и закоммитила их. Таким образом, строгая согласованность не гарантируется, и существует небольшое временное окно между обновлением данных в БД и обновлением тех же данных в кэше, во время которого параллельная транзакция может получить из кэша устаревшие данные.                                                                                                                 |
| transactional полноценное разделение транзакций                           | Полноценное разделение транзакций. Каждая сессия и каждая транзакция видят объекты, как если бы только они с ним работали последовательно одна транзакция за другой. Плата за это — блокировки и потеря производительности.                                                                                                                                                                                                                                      |
