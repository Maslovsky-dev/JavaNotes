---
tags: Java/Stream
---
[Stream API Java](https://javarush.com/groups/posts/2203-stream-api)
## Определение + BaseStream
Начиная с Java 8 появилась возможность работать с наборами данных (некое подобие функционального стиля программирования). Данный стиль упрощает фильтрации, сортировки и другие манипуляции с данными. java.util.stream

Stream API представляет канал передачи данных из источника данных. Источником могут быть файлы, массивы и коллекции.
В основе Stream API лежит интерфейс [[BaseStream]]

Все операции со Stream API бывают промежуточные (intermediate) или терминальными (termanal). Промежуточные возвращают трансформированный поток. Терминальные - конечный результат. После этого дальнейшее использования стрима невозможно. Вычисления производятся только на этапе терминальной операции.
**Стрим выполняется только во время его **

>[!Note] Ленивая инициализация
>это **оптимизация производительности, при которой вы откладываете (потенциально дорогостоящее) создание объекта до тех пор, пока оно вам действительно не понадобится**.

## Отличие коллекций от потоков
Несмотря на то, что все эти операции позволяют взаимодействовать с потоком как неким набором данных наподобие коллекции, важно понимать отличие коллекций от потоков:

— Потоки не хранят элементы. Элементы, используемые в потоках, могут храниться в коллекции, либо при необходимости могут быть напрямую сгенерированы.

— Операции с потоками не изменяют источника данных. Операции с потоками лишь возвращают новый поток с результатами этих операций.

— Для потоков характерно отложенное выполнение. То есть выполнение всех операций с потоком происходит лишь тогда, когда выполняется терминальная операция и возвращается конкретный результат, а не новый поток.
### Методы интерфейса Stream
[[Методы интерфейса Stream]]
## Создание стримов
Поток элементов может быть получен разными способами, например:

**Stream из List**

```java
List<String> list = new ArrayList<>();
list.stream();
list.parallelStream();           // параллельный поток
```

**Stream из Map**

```java
Map<String, String> map = new HashMap<>();
map.entrySet().stream();
map.values().stream();
```

**Stream из массива, используя статический метод класса Arrays**

```java
String[] array = new String[10];
Arrays.stream(array);
```

**Stream из элементов, используя статические методы Классов-потоков**

```java
Stream.of("a", "b", "c");        // поток из элементов
Stream.of(array);                // поток из элементов массива
Stream.of(list);                 // поток из элементов списка List
Stream.generate(Math::random);   // генерация потока рандомных чисел
Stream.concat(stream1, stream2); // объединяет два потока в один
IntStream.range(1, 10);          // поток диапазона чисел от 1 до 9
IntStream.rangeClosed(1, 10);    // поток диапазона чисел от 1 до 10
```

**Stream из строк буфера BufferedReader**

```java
BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
bufferedReader.lines();
```

**Stream из строк файла через статический метод класса Files**

```java
Path path = Path.of("/root/test.txt");
Files.lines(path);
```

**Stream из случайных чисел Random**

```java
Random random = new Random();
random.ints();
random.longs();
random.doubles();
```
![[Способы создания Стрима.png]]

Более подробно про стримы и их создание можно прочитать в статье “[Java Stream API ](https://habr.com/ru/post/693666/)”.

## IntStream и DoubleStream
Существуют специализированные stream-ы: **IntStream, LongStream, DoubleStream.**

У них есть все методы, что и в обычном Stream, но также существуют дополнительные методы: count, average, sum, min, max, range и другие.

Эти stream-ы специально созданы для примитивных типов, так как обычный Stream работает с объектами, а значит, в нем будут накладные расходы на автоупаковку и автораспаковку. Специализированные stream-ы есть только для int, long и double.
Для других примитивных типов специализированных stream-ов нет.
![[Пример использования IntStream.png]]

![[Операции в Stream.png]]
State full - каждый элемент знает друг о друге
Stateless - тем, кому превать на состоние других элементов.
## Промежуточные операции
[[Промежуточные операции]]
### Объединение потоков
Ряд методов Stream API возвращают подпотоки или объединенные потоки на основе уже имеющихся потоков. Рассмотрим эти методы.
### takeWhile
Метод takeWhile() выбирает из потока элементы, пока они соответствуют условию. Если попадается элемент, который не соответствует условию, то метод завершает свою работу. Выбранные элементы возвращаются в виде потока.

```java
import java.util.stream.Stream;
 
public class Program {
  
    public static void main(String[] args) {
          
        Stream<Integer> numbers = Stream.of(-3, -2, -1, 0, 1, 2, 3, -4, -5);
        numbers.takeWhile(n -> n < 0)
            .forEach(n -> System.out.println(n));
    }
}
```

В данном случае программа выбирает из потока числа, пока они меньше нуля. Консольный вывод программы:

```java
-3
-2
-1
```

При этом несмотря на то, что в потоке больше отрицательных чисел, но метод завершает работу, как только обнаружит первое число, которое не соответствует условию. В этом и состоит отличие, например, от метода filter().

Чтобы в данном случае охватить все элементы, которые меньше нуля, поток следует предварительно отсортировать:

```java
Stream<Integer> numbers = Stream.of(-3, -2, -1, 0, 1, 2, 3, -4, -5);
numbers.sorted().takeWhile(n -> n < 0)
        .forEach(n -> System.out.println(n));
```

Консольный вывод программы:

```java
-5
-4
-3
-2
-1
```

### Сoncat
Статический метод concat() объединяет элементы двух потоков, возвращая объединенный поток:

```java
import java.util.stream.Stream;
 
public class Program {
  
    public static void main(String[] args) {
          
        Stream<String> people1 = Stream.of("Tom", "Bob", "Sam");
        Stream<String> people2 = Stream.of("Alice", "Kate", "Sam");
         
        Stream.concat(people1, people2).forEach(n -> System.out.println(n));
    }
}
```

Консольный вывод:

```java
Tom
Bob
Sam
Alice
Kate
Sam
```


Более подробно про объединение потоков можно прочитать в статье “[Получение подпотока и объединение потоков](https://metanit.com/java/tutorial/10.13.php)”.

## Терминальные операции
[[Терминальные операции]]
## Класс Collectors и его методы
[[Класс Collectors и его методы]]
## Параллельные потоки
Фактически применение параллельных потоков сводится к тому, что **данные в потоке будут разделены на части, каждая часть обрабатывается на отдельном ядре процессора, и в конце эти части соединяются, и над ними выполняются финальные операции**

Рассмотрим несколько полезных методов, которые помогают управлять последовательными и параллельными стримами — как минимум быстро их определять.
![[Параллельные стимы.png]]
Не рекомендуется применять параллельность для выполнения долгих операций (например, извлечения данных из базы), потому что все стримы работают с общим пулом. Долгие операции могут остановить работу всех параллельных стримов в Java Virtual Machine из-за того, что в пуле не останется доступных потоков.

Чтобы избежать такой проблемы, используйте параллельные стримы только для коротких операций, выполнение которых занимает миллисекунды, а не секунды и тем более минуты.

## Типы стримов
1. Конечные и бесконечные
2. Параллельные и последовательные
3. Примитивов и ссылочных типов
