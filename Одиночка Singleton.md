---
tags: Паттерны
---

[Реализация паттерна Singleton в Java / Паттерны для всех, кто с ними столкнулся](https://javarush.com/groups/posts/589-patternih-i-singleton--dlja-vsekh-kto-vpervihe-s-nimi-stolknulsja)

`Singleton` относится к порождающим паттернам. Его дословный перевод – одиночка. Этот паттерн гарантирует, что у класса есть только один объект (один экземпляр класса) и к этому объекту предоставляется глобальная точка доступа. (Пример: только 1 соединение с базой данных)

## Особенность реализации `Singleton` в Java
Поведение Одиночки на Java невозможно реализовать с помощью обычного конструктора, потому что конструктор всегда возвращает новый объект. Поэтому все реализации `Singleton`’a сводятся к тому, чтобы **скрыть конструктор** и создать публичный статический метод, который будет управлять существованием объекта-одиночки и «уничтожать» всех вновь-появляющихся объектов. В случае вызова `Singleton`’a он должен либо создать новый объект (если его еще нет в программе), либо вернуть уже созданный. Для этого:

1. – Нужно добавить в класс приватное статическое поле, содержащее одиночный объект:

```java
public class LazyInitializedSingleton { 
	private static LazyInitializedSingleton instance; //#1 
}
```
2. – Сделать конструктор класса (конструктор по-умолчанию) приватным (чтобы доступ к нему был закрыть за пределами класса, тогда он не сможет возвращать новые объекты)

```java
public class LazyInitializedSingleton { 
	private static LazyInitializedSingleton instance; 
private LazyInitializedSingleton(){} // #2 
}
```
3. – Объявить статический создающий метод, который будет использоваться для получения одиночки

```java
public class LazyInitializedSingleton { 
	private static LazyInitializedSingleton instance; 
		private LazyInitializedSingleton(){} 
		public static LazyInitializedSingleton getInstance(){ // #3 
		if(instance == null){ //если объект еще не создан 
				instance = new LazyInitializedSingleton(); //создать новый объект 
		} 
		return instance; // вернуть ранее созданный объект 
	} 
}
```

В зависимости от сложности программы может потребоваться более детальная доработка этого паттерна. *Например, в многопоточной среде такая реализация может работать не корректно.*
## Ленивая инициализация
Ленивую инициализацию (Lazy Initialization) еще называют отложенной инициализацией. Это прием в программировании, когда ресурсоемкая операция (а создание объекта – это ресурсоемкая операция) выполняется по требованию, а не заблаговременно. Что в общем-то и происходит в нашем коде `Singleton`’a. Другими словами, наш объект создается в момент обращения к нему, а не заранее. Не следует полагать, что понятие ленивой инициализации как-то жестко связана именно с `Singleton`’ом. Отложенная инициализация также используется и в других порождающих паттернах проектирования, например в таких, как Proxy (Заместитель) и Factory Method (Фабричный метод)

## Почему Singleton называют анти-паттерном?
## **Нарушение принципа единственной ответственности** SOLID

В ООП существует правило хорошего тона — «Принцип единственной ответственности»
(Single Responsibility Principle, первая буква в аббревиатуре [[Принципы SOLID| SOLID]]).

Согласно этому правилу, каждый класс должен отвечать лишь за один какой-то аспект.
Но любой Singleton-класс **отвечает сразу за две вещи:** за то, что класс имеет лишь один
объект, и за реализацию того, для чего этот класс вообще был создан.

Принцип единственной ответственности был создан не просто так — если класс отвечает
за несколько действий, то, внося изменения в один аспект поведения класса, можно
затронуть и другой, что может сильно усложнить разработку.

Так же разработку усложняет тот факт, что пере-использование (reusability) класса
практически невозможно.

## **Поток** - **небезопасность**

Один из популярных вариантов реализации Singleton содержит ленивую инициализацию.
Это значит, что объект класса создаётся не в самом начале, а лишь когда будет получено
первое обращение к нему.

Однако здесь начинаются проблемы с потоками, которые могут создавать несколько
различных объектов. Происходит это примерно так:

- Первый поток обращается к **getInstance(),** когда объект ещё НЕ создан
- В это время второй тоже обращается к этому методу, пока первый ещё не успел
    создать объект, и сам создаёт его
- Первый поток создаёт ещё один, **второй, экземпляр класса**

Разумеется, можно просто пометить метод как **synchronized**, и эта проблема исчезнет.

Проблема заключается в том, что, сохраняя время на старте программы, мы теперь
будем терять его каждый раз при обращении к Singleton’у из-за того, что метод
синхронизирован, а **это очень дорого,** если к экземпляру приходится часто обращаться.

Единственный раз, когда свойство synchronized действительно требуется — **первое
обращение к методу.** Есть два способа решить эту проблему.

Первый — пометить как synchronized не весь метод, а только блок, где создаётся объект.
Не забывайте, что это нельзя использовать в версии Java ниже, чем 1.5, потому что там
используется иная модель памяти. Также не забудьте пометить поле instance как volatile.

Второй путь — **использовать паттерн «Lazy Initialization Holder».**
Это решение основано на том, что вложенные классы не инициализируются до первого
их использования (как раз то, что нам нужно)

## **Трудности с тестированием «одиночки»**

Один из главных минусов паттерна «Одиночка» — он сильно затрудняет юнит-
тестирование. «Одиночка» привносит в программу **глобальное состояние,** поэтому
нельзя просто взять и изолировать классы, которые полагаются на Singleton.

Поэтому, если нужно протестировать какой-то класс, то нужно вместе с ним тестировать и
Singleton, но это ещё полбеды. Состояние «Одиночки» может меняться, что порождает
следующие проблемы:

- Порядок тестов теперь имеет значение
- Тесты могут иметь нежелательные сторонние эффекты, порождённые Singleton’ом
- Вы не можете запускать несколько тестов параллельно
- Несколько вызовов одного и того же теста могут приводить к разным результатам.

На эту тему есть отличный доклад с «Google Tech Talks».

## **Загрузчик класса**

Если говорить о Java, то обеспечение существования лишь одного экземпляра класса,
которое так необходимо для Singleton, становится всё сложнее.

Проблема в том, что классическая реализация не проверяет, существует ли один
экземпляр на JVM, он лишь удостоверяется, что существует один экземпляр на
classloader. Если вы пишете небольшое клиентское приложение, в котором **используется
лишь один classloader, то никаких проблем не возникнет** (см. код выше).

Однако если используете несколько загрузчиков класса или ваше приложение должно
работать на сервере (где может быть запущено несколько экземпляров приложения в
разных загрузчиках классов), то всё становится очень печально.

## **Вывод**

Несмотря на то, что паттерн Singleton очень известный и популярный, у него есть
множество серьёзных недостатков. Чем дальше, тем больше этих недостатков
выявляется, и оригинальные паттерны из книги GOF «Design Patterns» часто сегодня
считаются анти-паттернами.

Тем не менее, сама идея иметь лишь один объект на класс по-прежнему имеет смысл, но
**достаточно сложно реализовать ее правильно.**
