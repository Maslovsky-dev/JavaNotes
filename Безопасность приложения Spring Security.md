---
tags: Spring/Security
---
Это фреймворк, набор фильтров сервлетов, которые помогают добавить, аутентификацию, авторизацию и защиту от распространенных атак.

## Как подключить к своему приложению?
Конфигурация с помощью аннотации @EnableWebSecurity (default @Configuration)
![[Включить SpringSecurity.png]]
- [[Метод configure Spring Security]]
- [[Защита от csrf атак Spring Security]]

## Основные интерфейсы Spring Security
Модуль позволяет добавлять права доступа, а также контролировать их исполнение. Базируется на двух интерфейсах, которые определяют связь сущностей с секьюрностью: **UserDetails** и **GrantedAuthority**.

**UserDetails** - то, что будет интерпретироваться системой как пользователь
**GrantedAuthority** - сущность, описывающая права юзера
Аутентификация и авторизация проходит до того, как запрос попадет в @Controllers

**Аутентификация** - процесс проверки подлинности. Проверка личности того, кто пытается получить доступ к определенному ресурсу путем сравнения введенного им логина и пароля с сохраненным в базе данных.
**Авторизация** - проверка и определение полномочий на выполнение определенных действий в соответствие с ранее выполненной аутентификацией.

### Principal, Authorities, Authentication
**Principal** - текущий вошедший в систему пользователь. Привязан к текущему потоку, запросу и сеансу. Фактически принципалом пользователя может выступать его логин, пароль или роль.
**Authorities** - предоставляют **полномочия(разрешения)**, которые были предоставлены принципалу (или например роли)
**Authentication** - объект с именем и паролем, полученным от пользователя и **требующим проверку**. Имя хранится в principal, а пароль в *credentials* (до проверки). 
![[Authenticated object.png|350]]
После аутентификации в поле Principal объекта Authentication будет **реальный пользователь в виде UserDetails**, поле Credentials обнуляется, то есть имя и пароль перемещается в Principal
## Авторизация
Где и как хранится инфо о пользователях?
![[Security Context.png]]
**Как это работает?**
1) Пользователь формирует POST запрос 2
2) Фильтр перехватывает и выдёргивает из запроса логин и пароль, далее формирует **UAPAT токен (Username And Password Authorization token)** 
3) Токен летит дальше и попадает в Authentication provider. Его задача провести аутентификацию и сказать, существует ли такой пользователь?
И если да, то кладём его в SPRING Security Context.
**Зачем тут нужны UserService и Authentication provider?**
- Провайдер получает токен (логин и пароль). 
- Провайдер обращается к UserDitailsService: есть у тебя такой юзер? 
- UserDitailsService знает, где юзеры хранятся и по username (byUserName) получает и возвращает настоящего юзера в виде объекта UserDitails (principal). 
- Далее Authentication provider берёт из токена пароль и делает проверку equals() 
- Если они равны, кладёт их в Spring Security Context.

Задачи Authentication provider: запросить настоящего юзера у UserDitailsService, сравнить пароль, почистить credentials (логин и пароль не сохраняются).

Spring хранит только **Authorities** (права доступа), а если нужна полная информация о клиенте, то нужно обратиться в базу данных.
### DaoAuthenticationProvider
Это реализация **AuthenticationProvider**, которая
использует **UserDetailsService** и [[PasswordEncoder]] для проверки подлинности имени пользователя и пароля.
![[Обработка запроса Autentication Provider.png]]
### InMemoryAuthentication и basicAuthentication
BasicAuthentication - механизм чтения имени и пароля пользователя, In-Memory Authentication - механизм хранения.

InMemory - означает, что пользователь хранится не в базе, а в оперативной памяти приложения до тех пор, пока оно запущено. Чтобы отредактировать пользователя, придется заново запускать приложение. Этот вариант полезен про разработки.

basicAuthentication - аутентификация путем сравнения пары идентификатор/пароль, зашифрованные с использованием кодировки base64 с теми, что хранятся в системе. Чтобы получить доступ к ресурсам (Resource), защищенным Basic Authentication, пользователь должен отправить request с информацией username/password прикрепленная в Header.

## Способы добавить секьюрность к контроллеру 

@Secured(Spring security annotation) используется для указания списка ролей в методе. Таким образом,  
пользователь может получить доступ к этому методу только в том случае, если у него есть хотя бы одна из указанных ролей. @RoleAllowed (Standard annotation of Java.) является аннотацией, эквивалентной аннотации @Secured 

@PreAuthorize проверяет данное выражение перед вводом метода, в то время как аннотация @PostAuthorize проверяет его после выполнения метода и может изменить результат.  
  
Аннотации @PreFilter и @PostFilter используются для фильтрации списков объектов на основе определяемых нами пользовательских правил безопасности.  
@PostFilter определяет правило для фильтрации списка возврата метода, применяя это правило к каждому элементу в списке. Если оцененное значение истинно, элемент будет сохранен в списке. В противном случае элемент будет удален.  
@PreFilter работает очень похожим образом, однако фильтрация применяется к списку, который передается в качестве входного параметра аннотированному методу.  
  
//\\\\\\\\\\\\\\\\  
**Тoken Authentication** (Проверка подлинности токена. Токен выдается сервером.)  
**Basic Authentication** (Базовая аутентификация. Пароль-логин.)  
**Digest Authentication** (Данный метод отправляет по сети хеш - сумму логина, пароля, адреса сервера и случайных данных, и предоставляет больший уровень защиты, чем базовая аутентификация, при которой данные отправляются в открытом виде.)  
**Digital Signature** (public/private key pair) Цифровая подпись (пара открытого/закрытого ключей). 
**OAuth2 authorization**(Авторизация OAuth2. Схема авторизации, обеспечивающая предоставление третьей стороне ограниченный доступ к защищенным ресурсам пользователя без передачи ей (третьей стороне) логина и пароля)

