---
tags: SQL
---
Оператор HAVING = Группировка + Фильтрация данных по агрегирующему значению

```sql
SELECT customer_id, SUM(total_amount) as total_spent
FROM orders
GROUP BY customer_id
HAVING SUM(total_amount) > 1000;
```
В этом запросе:

- `SELECT customer_id, SUM(total_amount) as total_spent` выбирает идентификатор заказчика и сумму всех его заказов. `as total_spent` указывает, что результат выражения `SUM(total_amount)` будет доступен в результате как `total_spent`. Это позволяет обращаться к этому выражению по более понятному имени вместо полного имени столбца.
- `FROM orders` указывает на таблицу "orders".
- `GROUP BY customer_id` группирует записи по идентификатору заказчика.
- `HAVING SUM(total_amount) > 1000` фильтрует группы (заказчиков), оставляя только те, у которых суммарная сумма заказов больше 1000.

Таким образом, результатом этого запроса будут заказчики, у которых общая сумма заказов превышает 1000.
## Порядок выполнения SQL запроса

Но почему же мы не могли использовать WHERE и зачем нужен отдельный оператор для этой цели? Все дело в порядке выполнения SQL запроса.

![Схема порядка выполнения SQL запроса|450](https://sql-academy.org/static/guidePage/operator-having/sql_query_order_ru.png "Схема порядка выполнения SQL запроса")

Наш первый запрос был неверный, потому что мы пытались использовать поле **avg_price** у образовавшихся групп ещё до их образования, так как выполнение оператора **WHERE** предшествует группировке.
## Общая структура запроса с оператором HAVING


```sql
SELECT [константы, агрегатные_функции, поля_группировки]
FROM имя_таблицы
WHERE условия_на_ограничения_строк
GROUP BY поля_группировки
HAVING условие_на_ограничение_строк_после_группировки
ORDER BY условие_сортировки
```
