---
tags: Паттерны
---
**Строитель** — это порождающий паттерн проектирования, который позволяет **создавать сложные объекты пошагово.**
Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

## **Проблема**

Представьте сложный объект, требующий кропотливой пошаговой инициализации множества полей и вложенных объектов. Код инициализации таких объектов обычно спрятан внутри монструозного конструктора с десятком параметров. Либо ещё хуже — распылён по всему клиентскому коду.
![[Проблема паттерн Строитель.png]]

Чтобы не плодить подклассы, вы можете подойти к решению с другой стороны. Вы можете создать гигантский конструктор Дома, принимающий уйму параметров для контроля над создаваемым продуктом. Действительно, это избавит вас от подклассов, но приведёт к другой проблеме.

>[!note]
>Большая часть этих параметров будет **простаивать**, а вызовы конструктора будут выглядеть монструозно из-за длинного списка параметров. К примеру, далеко не каждый дом имеет бассейн, поэтому параметры, связанные с бассейнами, будут простаивать бесполезно в 99% случаев.

## **Решение**

Паттерн Строитель предлагает **вынести конструирование объекта за пределы** его собственного класса, поручив это дело отдельным объектам, называемым строителями.

Паттерн предлагает разбить процесс конструирования объекта на отдельные шаги (например, `построитьСтены` ( `вставитьДвери` и другие). Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации.

Зачастую один и тот же шаг строительства может отличаться для разных вариаций производимых объектов. Например, деревянный дом потребует строительства стен из дерева, а каменный - из камня.

В этом случае вы можете создать несколько классов строителей, выполняющих одни и те же шаги по-разному. Используя этих строителей в одном и том же строительном процессе, вы сможете получать на выходе различные объекты.

![[Строитель паттерн.png]]

Код, который вызывает шаги строительства, должен работать со строителями через **общий интерфейс,** чтобы их можно было свободно взаимозаменять.

## **Директор**

Вы можете пойти дальше и выделить вызовы методов строителя в отдельный класс,
называемый **директором**. В этом случае директор будет задавать порядок шагов строительства, а строитель — выполнять их.

Директор полезен, если у вас есть несколько способов конструирования продуктов, отличающихся порядком и наличием шагов конструирования. В этом случае вы сможете объединить всю эту логику в одном классе.

Такая структура классов полностью скроет от клиентского кода процесс конструирования объектов. Клиенту останется только привязать желаемого строителя к директору, а затем получить у строителя готовый результат.
Структура и псевдокод по ссылке: https://refactoring.guru/ru/design-patterns/builder

## Когда применять?
1. Когда хотите избавиться от «телескопического конструктора».

Допустим, у вас есть один конструктор с десятью опциональными параметрами. Его неудобно вызывать, поэтому вы создали ещё десять конструкторов с меньшим количеством параметров. Всё, что они делают — это переадресуют вызов к базовому конструктору, подавая какие-то значения по умолчанию в параметры, которые пропущены в них самих.

Паттерн Строитель позволяет собирать объекты пошагово, вызывая только те шаги,
которые вам нужны.

2. Когда код должен создавать разные представления какого-то объекта (например,
    деревянные и железобетонные дома).

>[!note] Строитель можно применить, если создание нескольких представлений объекта состоит из **одинаковых этапов,** которые отличаются в деталях.
>Интерфейс строителей определит все возможные этапы конструирования. Каждому
представлению будет соответствовать собственный класс-строитель. А порядок этапов
строительства будет задавать класс-директор.

3. Когда нужно собирать сложные составные объекты, например, деревья
    Компоновщика.

Строитель конструирует объекты пошагово, а не за один проход. Более того, шаги
строительства можно выполнять рекурсивно. А без этого не построить древовидную
структуру, вроде Компоновщика.

Строитель не позволяет посторонним объектам иметь доступ к конструируемому объекту,
пока тот не будет полностью готов. Это предохраняет клиентский код от получения
**незаконченных «битых» объектов.**

## **Шаги реализации**

- Убедитесь в том, что создание разных представлений объекта можно свести к общим шагам.
- Опишите эти шаги в общем интерфейсе строителей.
- Для каждого из представлений объекта-продукта создайте по одному классу-строителю и реализуйте их методы строительства.
- Подумайте о создании класса директора. Его методы будут создавать различные конфигурации продуктов, вызывая разные шаги одного и того же строителя.
- Клиентский код должен будет создавать и объекты строителей, и объект директора.

Перед началом строительства клиент должен связать определённого строителя с директором. Это можно сделать либо через конструктор, либо через сеттер, либо подав строителя напрямую в строительный метод директора.

- Результат строительства можно вернуть из директора, но только если метод
    возврата продукта удалось поместить в общий интерфейс строителей.
    Иначе вы жёстко привяжете директора к конкретным классам строителей.

## ![[Преимущества и недостатки паттерна Строителя.png]]

## Пример реализации


```java
// Продукт
class House {
    private String foundation;
    private String structure;
    private String roof;

    public void setFoundation(String foundation) {
        this.foundation = foundation;
    }

    public void setStructure(String structure) {
        this.structure = structure;
    }

    public void setRoof(String roof) {
        this.roof = roof;
    }
    // ... другие методы для работы с домом
}

// Интерфейс строителя
interface HouseBuilder {
    void buildFoundation();
    void buildStructure();
    void buildRoof();
    House getResult();
}

// Конкретный строитель
class ConcreteHouseBuilder implements HouseBuilder {
    private House house = new House();

    public void buildFoundation() {
        house.setFoundation("Concrete");
    }

    public void buildStructure() {
        house.setStructure("Concrete Blocks");
    }

    public void buildRoof() {
        house.setRoof("Concrete Slab");
    }

    public House getResult() {
        return house;
    }
}

// Директор
class CivilEngineer {
    private HouseBuilder houseBuilder;

    public CivilEngineer(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }

    public House getHouse() {
        return houseBuilder.getResult();
    }

    public void constructHouse() {
        houseBuilder.buildFoundation();
        houseBuilder.buildStructure();
        houseBuilder.buildRoof();
    }
}

// Клиентский код
public class Client {
    public static void main(String[] args) {
        //Создаем строителя
        HouseBuilder concreteHouseBuilder = new ConcreteHouseBuilder(); 
        // Создаем директра и привязываем к нему конструктра
        CivilEngineer civilEngineer = new CivilEngineer(concreteHouseBuilder); 
        civilEngineer.constructHouse();
        House house = civilEngineer.getHouse();
        System.out.println("Constructed House with: " +
                house.getFoundation() + ", " +
                house.getStructure() + ", " +
                house.getRoof());
    }
}

```
