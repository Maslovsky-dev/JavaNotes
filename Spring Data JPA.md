---
tags: Spring/Data
---
## Какие задачи решает Spring Data
Это проект, который упрощает работу с системами доступа к данным: реляционными и нереляционными базами данных, [[Map-reduce]] фреймворками и облачными хранилищами.

Центральная концепция проекта – репозитории из предметно-ориентированного дизайна Domain-driven design, DDD.
- [ ] Написать подробнее про DDD

Spring Data состоит из множества отдельных библиотек для разных случаев жизни.
Вот самые популярные из них:
- Spring Data JPA – адаптер для реализаций Java Persistence API, таких как Hibernate.
- Spring Data JDBC – более простой и ограниченный чем JPA адаптер для JDBC-драйверов.
- Spring Data REST – создание готовых hypermedia-driven RESTful сервисов на основе репозиториев.
- Spring Data KeyValue – работа с хранилищами типа ключ-значение.
- Библиотеки поддержки конкретных реализаций хранилищ: MongoDB, Redis, Cassandra, LDAP, и других.

**Основная часть работы в Spring Data строится вокруг интерфейса Repository.**

Это маркерный интерфейс. От него наследуются интерфейсы-специализации, которые уже содержат методы для работы с сущностями базы данных. Все эти интерфейсы параметризуются двумя типами: самой сущности и её идентификатора.
## Иерархия интерфейсов/классов репозитория в Spring Data JPA?
![[Иерархия классов и интерфейсов Spring Data JPA.png]]
**Repository** (маркерный интерфейс, не содержит методов) — это интерфейс верхнего уровня, определенный в Spring Data Hierarchy.

Интерфейс **CrudRepository** расширяет интерфейс репозитория, предоставляет методы для выполнения операции CRUD.

**PagingAndSortingRepository** расширяет интерфейс **CrudRepository** и предоставляет дополнительные методы для извлечения сущностей с помощью разбиения на страницы и сортировки.

Интерфейс **QueryByExampleExecutor**, используется для выполнения запроса по примеру.
Интерфейс **JpaRepository** расширяет интерфейс PagingAndSortingRepository и QueryByExampleExecutor, предоставляя некоторые дополнительные пакетные методы.

**SimpleJpaRepository** — это класс реализации интерфейса CrudRepository.

## Блокировки Spring Data Jpa
### Типы блокировки[​](https://for-each.dev/lessons/b/-java-jpa-transaction-locks#2-%D1%82%D0%B8%D0%BF%D1%8B-%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8 "Прямая ссылка на 2. Типы блокировки")

В JPA определены два основных типа блокировки: пессимистическая блокировка и оптимистичная блокировка.

### Пессимистическая блокировка

**Когда мы используем [пессимистическую блокировку](https://for-each.dev/lessons/b/-jpa-pessimistic-locking) в транзакции и получаем доступ к объекту, он будет немедленно заблокирован**. Транзакция освобождает блокировку, фиксируя или откатывая транзакцию.

###  Оптимистичная блокировка[

**В [Optimistic Locking](https://for-each.dev/lessons/b/-jpa-optimistic-locking) транзакция не блокирует объект немедленно.** Вместо этого транзакция обычно сохраняет состояние объекта с присвоенным ему номером версии.

Когда мы пытаемся обновить состояние объекта в другой транзакции, транзакция сравнивает сохраненный номер версии с существующим номером версии во время обновления.

На этом этапе, если номер версии отличается, это означает, что сущность не может быть изменена. Если есть активная транзакция, то эта транзакция будет отменена, и базовая реализация JPA выдаст исключение `OptimisticLockException.`

Помимо подхода с номером версии, мы можем использовать другие подходы, такие как временные метки, вычисление хэш-значения или сериализованная контрольная сумма, в зависимости от того, какой подход наиболее подходит для нашего текущего контекста разработки.

###  Включение блокировки транзакций для методов запроса[

**Чтобы получить блокировку объекта, мы можем аннотировать целевой метод запроса аннотацией `Lock`, передав требуемый тип режима блокировки** `.`

[[LockModeType|Типы режима блокировки]]— это значения перечисления, которые необходимо указать при блокировке объекта. Затем указанный режим блокировки распространяется на базу данных, чтобы применить соответствующую блокировку к объекту сущности.

Чтобы указать блокировку для пользовательского метода запроса репозитория Spring Data JPA, мы можем аннотировать метод с помощью `@Lock` и указать требуемый тип режима блокировки:

```java
@Lock(LockModeType.OPTIMISTIC_FORCE_INCREMENT)@Query("SELECT c FROM Customer c WHERE c.orgId = ?1")public List<Customer> fetchCustomersByOrgId(Long orgId);
```

Чтобы применить блокировку к предопределенным методам репозитория, таким как `findAll` или `findById(id)` , мы должны объявить метод в репозитории и аннотировать метод аннотацией `Lock` :

```java
@Lock(LockModeType.PESSIMISTIC_READ)public Optional<Customer> findById(Long customerId);
```

Когда блокировка включена явно и нет активной транзакции, базовая реализация JPA выдаст исключение `TransactionRequiredException` .

Если блокировка не может быть предоставлена и конфликт блокировок не приводит к откату транзакции, JPA [`генерирует исключение LockTimeoutException`](https://docs.oracle.com/javaee/7/api/javax/persistence/LockTimeoutException.html) . Но он не помечает активную транзакцию для отката.

###  Установка времени ожидания блокировки транзакции

При использовании пессимистической блокировки база данных попытается немедленно заблокировать объект. Базовая реализация JPA выдает `исключение LockTimeoutException` , когда блокировка не может быть получена немедленно. Чтобы избежать таких исключений, мы можем указать значение тайм-аута блокировки.

В Spring Data JPA время ожидания блокировки можно указать с помощью аннотации [`QueryHints`](https://docs.spring.io/spring-data/jpa/docs/current/api/index.html?org/springframework/data/jpa/repository/QueryHints.html) , поместив [`QueryHint`](https://docs.oracle.com/javaee/7/api/javax/persistence/QueryHint.html) в методы запроса:

```java
@Lock(LockModeType.PESSIMISTIC_READ)@QueryHints({@QueryHint(name = "javax.persistence.lock.timeout", value = "3000")})public Optional<Customer> findById(Long customerId);
```

Дополнительные сведения о настройке тайм-аута блокировки для разных областей можно найти в этой [статье ObjectDB](https://www.objectdb.com/java/jpa/persistence/lock#Pessimistic_Locking_) .
##  Вывод

В этом руководстве мы изучили различные типы режимов блокировки транзакций. Мы узнали, как включить блокировку транзакций в Spring Data JPA. Мы также рассмотрели настройку времени ожидания блокировки.
