---
tags: Java/Многопоточность
--- 
[Атомарные классы пакета util.concurrent](https://java-online.ru/concurrent-atomic.xhtml)
Atomic-типы данных в Java, представленные в классах `java.util.concurrent.atomic`, предоставляют атомарные операции чтения и записи над примитивными типами данных. Они используются для обеспечения безопасной многопоточной работы с переменными без необходимости использования блокировок или [[Синхронизация в Java|синхронизации]].

>[!Example]+ Пример с дикрементом
>С точки зрения программиста операции инкремента (i++, ++i) и декремента (i--, --i) выглядят наглядно и компактно. Но, с точки зрения JVM (виртуальной машины Java) данные операции не являются атомарными, поскольку требуют выполнения нескольких действительно атомарных операции: чтение текущего значения, выполнение инкремента/декремента и запись полученного результата. При работе в многопоточной среде операции инкремента и декремента могут стать источником ошибок. Т.е. в многопоточной среде простые с виду операции инкремента и декремента требуют использование синхронизации и блокировки. Но блокировки содержат массу недостатков, и для простейших операций инкремента/декремента являются тяжеловесными. Выполнение блокировки связано со средствами операционной системы и несёт в себе опасность приостановки с невозможностью дальнейшего возобновления потока, а также опасность взаимоблокировки или инверсии приоритетов (priority inversion). Кроме этого, появляются дополнительные расходы на переключение потоков. _Но можно ли обойтись без блокировок? В ряде случаев можно!_
>
Блокировка подразумевает **пессимистический** подход, разрешая только одному потоку выполнять определенный код, связанный с изменением значения некоторой «общей» переменной. Таким образом, никакой другой поток не имеет доступа к определенным переменным. Но можно использовать и **оптимистический** подход. В этом случае блокировки не происходит, и если поток обнаруживает, что значение переменной изменилось другим потоком, то он повторяет операцию снова, но уже с новым значением переменной. Так работают атомарные классы.
>

## Описание атомарного класса AtomicLong

Рассмотрим принцип действия механизма **оптимистической блокировки** на примере атомарного класса AtomicLong, исходный код которого представлен ниже. В этом классе переменная value объявлена с модификатором _volatile_, т.е. её значение могут поменять разные потоки одновременно. Модификатор _volatile_ гарантирует выполнение отношения [[Happens before]], что ведет к тому, что измененное значение этой переменной увидят все потоки.

Каждый атомарный класс включает метод **compareAndSet**, представляющий механизм _оптимистичной блокировки_ и позволяющий изменить значение value только в том случае, если оно равно ожидаемому значению (т.е. current). Если значение value было изменено в другом потоке, то оно не будет равно ожидаемому значению. Следовательно, метод compareAndSet вернет значение false, что приведет к новой итерации цикла while в методе getAndAdd. Таким образом, в очередном цикле в переменную current будет считано обновленное значение value, после чего будет выполнено сложение и новая попытка записи получившегося значения (т.е. next). Переменные **current** и **next** - локальные, и, следовательно, у каждого потока свои экземпляры этих переменных.

``` java
private volatile long value;
 
public final long get() {
    return value;
}
 
public final long getAndAdd(long delta) {
    while (true) {
        long current = get();
        long next = current + delta;
        if (compareAndSet(current, next))
            return current;
    }
}
```

## Семейство Atomic
 **AtomicBoolean, AtomicInteger, AtomicLong**:
	- Операции с этими классами работают быстрее, чем если синхронизироваться через synchronized/volatile; 
	- Существуют методы для атомарного добавления на заданную величину, а также инкремент/декремент.
**AtomicIntegerArray, AtomicLongArray** – классы с массивами
**AtomicReference** – класс для атомарных операций со ссылкой на объект.
**AtomicMarkableReference** – класс для атомарных операций со следующей парой полей: ссылка на объект и битовый флаг true/false.
**AtomicStampedReference** – класс для атомарных операций со следующей парой полей: ссылка на объект и int значение.
**AtomicReferenceArray** – массив ссылок на объекты, которые могут атомарно обновляться.
## Отличие от volatile
1. **Атомарность операций**: Atomic-типы данных обеспечивают атомарные операции чтения и записи, в то время как `volatile` переменные гарантируют только видимость изменений между потоками. Atomic-типы данных позволяют выполнять более сложные атомарные операции, такие как инкремент, декремент, сравнение и обмен.
2. **Расширенная функциональность**: Atomic-типы данных предоставляют дополнительные методы для выполнения атомарных операций над переменными, такие как инкремент, декремент, арифметические операции и операции сравнения и обмена. В то же время `volatile` переменные ограничены операциями чтения и записи.
3. **Типизация**: Atomic-типы данных доступны для различных примитивных типов данных, таких как `int`, `long`, `boolean`, `double` и т.д., в то время как `volatile` переменные могут быть применены только к переменным этих примитивных типов.

В целом, Atomic-типы данных предоставляют более широкий набор функциональных возможностей для безопасной многопоточной работы с переменными. Они позволяют выполнять атомарные операции чтения и записи, а также более сложные операции сравнения и обмена, обеспечивая безопасность и согласованность данных в многопоточной среде.


