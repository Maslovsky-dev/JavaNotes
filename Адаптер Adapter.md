---
tags: Паттерны
--- 
И еще про паттерн Адаптер (из того, что мы программировали в задачах): контроллер принимает http-запрос в виде json (или другие сырые форматы) и далее с помощью библиотеки Джексон конвертирует их в объекты java. Это тоже яркий пример паттерна Адаптер.

**Адаптер** — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами **работать вместе.**
![[Паттерн Адаптер Img.png]]

**Проблема**

Представьте, что вы делаете приложение для торговли на бирже. Ваше приложение скачивает биржевые котировки из нескольких источников в XML, а затем рисует красивые графики.

В какой-то момент вы решаете улучшить приложение, применив стороннюю библиотеку аналитики. Но вот беда — библиотека поддерживает только формат данных JSON, несовместимый с вашим приложением.

Вы смогли бы переписать библиотеку, чтобы та поддерживала формат XML.

Но, во-первых, это может нарушить работу существующего кода, который уже зависит от библиотеки. А во-вторых, у вас может просто не быть доступа к её исходному коду.
![[Пример паттерна Адаптер торговля на бирже.png]]

**Решение**

Вы можете создать адаптер. Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.

При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого. Например, вы можете обернуть объект, работающий в метрах, адаптером, который бы конвертировал данные в футы.

Адаптеры могут не только переводить данные из одного формата в другой, но и помогать объектам с разными интерфейсами работать сообща. Это работает так:
- Адаптер имеет интерфейс, который совместим с одним из объектов.
- Поэтому этот объект может свободно вызывать методы адаптера.
- Адаптер получает эти вызовы и перенаправляет их второму объекту, но уже в том формате и последовательности, которые понятны второму объекту.

Иногда возможно создать двухсторонний адаптер, который работает в обе стороны.

Таким образом, в приложении биржевых котировок вы могли бы создать класс XML\_To\_JSON\_Adapter, который бы оборачивал объект того или иного класса библиотеки аналитики. Ваш код посылал бы адаптеру запросы в формате XML, а адаптер сначала транслировал входящие данные в формат JSON, а затем передавал бы их методам обёрнутого объекта аналитики.

Структура и псевдокод по ссылке → https://refactoring.guru/ru/design-patterns/adapter

## **Когда применять?**

1. Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.
	Адаптер позволяет создать объект-прокладку, который будет превращать вызовы приложения в формат, понятный стороннему классу.

2. Когда нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности, причём расширить суперкласс нельзя.
	Можно создать ещё один уровень подклассов и добавить в них недостающую функциональность, но при этом придётся дублировать один и тот же код в обеих ветках подклассов.

	Более элегантным решением было бы поместить недостающую функциональность в адаптер и приспособить его для работы с суперклассом. Такой адаптер сможет работать со всеми подклассами иерархии. Это решение будет сильно напоминать **паттерн Декоратор.**

## **Шаги реализации**

- Убедитесь, что у вас есть два класса с несовместимыми интерфейсами:
	- полезный сервис — служебный класс, который вы не можете изменять (он либо сторонний, либо от него зависит другой код);
	- один или несколько клиентов — существующих классов приложения, несовместимых с сервисом из-за неудобного или несовпадающего интерфейса.
- Опишите клиентский интерфейс, через который классы приложения смогли бы использовать класс сервиса.
- Создайте класс адаптера, реализовав этот интерфейс.
- Поместите в адаптер поле, которое будет хранить ссылку на объект сервиса. Обычно это поле заполняют объектом, переданным в конструктор адаптера. В случае простой адаптации этот объект можно передавать через параметры методов адаптера.
- Реализуйте все методы клиентского интерфейса в адаптере. **Адаптер должен делегировать основную работу сервису.**
- Приложение должно использовать адаптер только через клиентский интерфейс. Это позволит легко изменять и добавлять адаптеры в будущем.
## ![[Преимущества и недостатки паттерна Адаптер.png]]
## Пример реализации

Допустим, у нас есть старая система, которая предоставляет интерфейс для печати документов:

```java
// Старый интерфейс для печати документов
interface OldPrinter {
    void print(String document);
}

// Конкретная реализация старого принтера
class LegacyPrinter implements OldPrinter {
    public void print(String document) {
        System.out.println("Printing document: " + document);
    }
}

```

Теперь предположим, что у нас есть новая система, которая ожидает объекты, реализующие другой интерфейс для печати документов:

```java
// Новый интерфейс для печати документов
interface NewPrinter {
    void printDocument(String document);
}

// Конкретная реализация нового принтера
class ModernPrinter implements NewPrinter {
    public void printDocument(String document) {
        System.out.println("Printing document: " + document);
    }
}
```

Чтобы использовать старый принтер (`LegacyPrinter`) в новой системе, мы можем создать адаптер, который преобразует интерфейс старого принтера к интерфейсу новой системы:

```java
// Адаптер для преобразования старого принтера к новому интерфейсу
class PrinterAdapter implements NewPrinter {
    private OldPrinter oldPrinter;

    public PrinterAdapter(OldPrinter oldPrinter) {
        this.oldPrinter = oldPrinter;
    }

    public void printDocument(String document) {
        // Вызов старого метода через адаптер
        oldPrinter.print(document);
    }
}

```

Теперь мы можем использовать адаптер `PrinterAdapter`, чтобы использовать старый принтер `LegacyPrinter` в новой системе:

```java
public class Client {
    public static void main(String[] args) {
        // Используем новый принтер в новой системе
        NewPrinter modernPrinter = new ModernPrinter();
        modernPrinter.printDocument("New document");

        // Используем старый принтер через адаптер в новой системе
        OldPrinter oldPrinter = new LegacyPrinter();
        NewPrinter adaptedPrinter = new PrinterAdapter(oldPrinter);
        adaptedPrinter.printDocument("Old document");
    }
}
```

Как видно из примера, адаптер (`PrinterAdapter`) позволяет использовать объекты старого интерфейса (`OldPrinter`) в новой системе, которая ожидает объекты нового интерфейса (`NewPrinter`), без изменения кода существующих классов. Адаптер делает старый интерфейс совместимым с новым интерфейсом, что позволяет повторно использовать и переиспользовать существующий код в различных контекстах.
