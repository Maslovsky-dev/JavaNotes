---
tags: Java/ФИ
--- 
## Лямбда выражения
Лямбда представляет набор инструкций, которые можно выделить в отдельную переменную и потом использовать многократно в различных местах программы.
![[Лямбда конструкция.png|300]]

Лямбда оператор -> разделяет выражение на две части. Левая часть содержит список параметров выражения, а правая - тело выражения, где выполняются все действия.
> [!NOTE]
> Лямбда-выражение не выполняется само по себе, а образует **реализацию метода, определенного в функциональном интерфейсе**. При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.

Пример
```java
public class LambdaApp {
 
    public static void main(String[] args) {
         
        Operationable operation;
        operation = (x,y)->x+y;
         
        int result = operation.calculate(10, 20);
        System.out.println(result); //30
    }   
}
interface Operationable{
    int calculate(int x, int y);
}
```

То же самое можно переписать и с помощью анонимных классов
```java
public class LambdaApp {
 
    public static void main(String[] args) {
         
        Operationable op = new Operationable(){
         
            public int calculate(int x, int y){
             
                return x + y;
            }
        };
         int z = op.calculate(20, 10);
         System.out.println(z); // 30
    }   
}
interface Operationable{
    int calculate(int x, int y);
}
```
Если лямбда выражения вызывают только один существующий метод, лучше ссылаться на этот метод по его имени. Ссылки на методы (_Method References)_ – это компактные лямбда выражения для методов у которых уже есть имя. Например:

```java
Consumer<String> consumer = str -> System.out.println(str);
```
## Создание и использование лямбда выражения
0. Определение ссылки на функциональный интерфейс:

```java
Operationable operation;
```

1. Создание лямбда-выражения:

```java
operation = (x,y)->x+y;
```

Причем параметры лямбда-выражения соответствуют параметрам единственного метода интерфейса Operationable, а результат соответствует возвращаемому результату метода интерфейса. При этом нам не надо использовать ключевое слово return для возврата результата из лямбда-выражения.
2. Использование лямбда-выражения в виде вызова метода интерфейса:

```java
int result = operation.calculate(10, 20);
```

Так как в лямбда-выражении определена операция сложения параметров, результатом метода будет сумма чисел 10 и 20.

При этом для одного функционального интерфейса мы можем определить множество лямбда-выражений. Например:

```java
Operationable operation1 = (int x, int y)-> x + y;
Operationable operation2 = (int x, int y)-> x - y;
Operationable operation3 = (int x, int y)-> x * y;
         
System.out.println(operation1.calculate(20, 10)); //30
System.out.println(operation2.calculate(20, 10)); //10
System.out.println(operation3.calculate(20, 10)); //200
```

## Методы и конструкторы
Одним из преимуществ лямбд в java является то, что их можно передавать в качестве параметров в методы. Рассмотрим пример:

```java
public class LambdaApp {
 
    public static void main(String[] args) {
         
        Expression func = (n)-> n%2==0;
        int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
        System.out.println(sum(nums, func)); // 20
    } 
    private static int sum (int[] numbers, Expression func)
    {
        int result = 0;
        for(int i : numbers)
        {
            if (func.isEqual(i))
                result += i;
        }
        return result;
    }
}
 
interface Expression{
    boolean isEqual(int n);
}
```

Функциональный интерфейс Expression определяет метод isEqual(), который возвращает true, если в отношении числа n действует какое-нибудь равенство.

В основном классе программы определяется метод sum(), который вычисляет сумму всех элементов массива, соответствующих некоторому условию. А само условие передается через параметр Expression func. Причем на момент написания метода sum мы можем абсолютно не знать, какое именно условие будет использоваться. Само же условие определяется в виде лямбда-выражения:

```java
Expression func = (n)-> n%2==0;
```

То есть в данном случае все числа должны быть четными или остаток от их деления на 2 должен быть равен 0. Затем это лямбда-выражение передается в вызов метода sum.

При этом можно не определять переменную интерфейса, а сразу передать в метод лямбда-выражение:

```java
int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
int x = sum(nums, (n)-> n > 5); // сумма чисел, которые больше 5
System.out.println(x);  // 30
```

Начиная с JDK 8 в Java можно в качестве параметра в метод передавать ссылку на другой метод. Ссылка на метод передается в виде имя_класса::имя_статического_метода (если метод статический) или объект_класса::имя_метода (если метод нестатический).

 Ссылки на конструкторы

Подобным образом мы можем использовать конструкторы: название_класса::new. Например:

```java
public class LambdaApp {
 
    public static void main(String[] args) {
         
        UserBuilder userBuilder = User::new;
        User user = userBuilder.create("Tom");
        System.out.println(user.getName());
    }
}
interface UserBuilder{
    User create(String name);
}
 
class User{
     
    private String name;
    String getName(){
        return name;
    }
     
    User(String n){
        this.name=n;
    }
}
```

При использовании конструкторов методы функциональных интерфейсов должны принимать тот же список параметров, что и конструкторы класса, и должны возвращать объект данного класса.

Более подробно про методы и конструкторы можно прочитать в статье “[Лямбды как параметры и результаты методов](https://metanit.com/java/tutorial/9.2.php)”.

## Сравнение лямбда и анонимных классов

![[Лямбда и анонимные классы.png]]
## Ограничения 
![[Ограничения лямбд.png]]
![[Лямбды ошибки синтаксиса.png]]
