---
tags: Java
aliases: мусор, сборщик мусора
---
В Java используется автоматическое управление памятью. Программист выделяет память, а за освобождение отвечает JVM. Когда программа больше не ссылается на объект (прямые или косвенные ссылки), то объект удаляется, а память переиспользуется. Сборщик мусора – это [[демон-поток]], который выполняет две задачи: **поиск и очистка мусора**.

## Что такое мусор, как определить, что объекты мёртвые?

### Учет ссылок (Reference counting)
**Если объект не имеет ссылок, он считается мусором.**
Проблема: невозможно выявить циклические ссылки (когда два объекта не имеют внешних ссылок, но ссылаются друг на друга (но не имеют внешних ссылок)-> приводит к утечке памяти)
[Учёт ссылок не используется в HotSpot JVM](https://medium.com/nuances-of-programming/%D1%81%D0%B1%D0%BE%D1%80%D0%BA%D0%B0-%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0-%D0%B2-java-%D1%87%D1%82%D0%BE-%D1%8D%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B8-%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D0%B2-jvm-25bb2570b44c)

### Трассировка (Tracing)
Используется в HotSpot (популярная разновидность JVM).
До объекта можно добраться из корневых точек (GC root).

Типы корневых точек GC Roots java приложения:
- объекты в статических полях классов
- объекты, доступные из стека потоков
- объекты из JNI (Java Native Interface) ссылок в native методах

Если до чего-то добраться нельзя, то это мусор.
Всё, что доступно из «живого» объекта, также является «живым».

[[Процесс сборки мусора]]

[[Сборщики мусора в Java]]

## Производительность сборщиков мусора
- Throughput (пропускная способность) – объём вычислительных ресурсов, затрачиваемых GC
- Latency (задержка) – на какое время прерывается работа приложения
- Footprint (след) – объём используемой памяти
Можно и нужно выбирать оптимальную стратегию, исходя из целей разработки.
![[Выбор Gc Img.png]]
## Два подхода к сборке мусора, два алгоритма работы:
**STW «stop-the-world»** - остановка приложения на период уборки (остановка нужна, чтоб никакие новые изменения не произошли в программе, новые объекты не появились и т.д.)

**Инкрементальная сборка**
- Попытка уменьшить паузы, вызванные GC (за счёт большого количества коротких пауз и фоновой сборки)
- Требуется синхронизировать работу GC с приложением (барьеры на чтение/запись) Такой алгоритм занимает больше времени.
![[Сравнение STW подхода и инкрементальной сборки.png|400]]
