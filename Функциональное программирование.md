
Функциональное программирование - программирование с математическими функциями
1. Referentially transparent
![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/df1/663/5e9/df16635e930ef1a715fd4635fc76ad70.png)


Для того чтобы **метод** стал **математической функцией**, он должен соответствовать двум требованиям. Прежде всего, он должен быть ссылочно прозрачным (referentially transparent). Ссылочно прозрачная функция всегда дает один и тот же результат, если вы предоставляете ей одни и те же аргументы. Это означает, что такая функция должна работать только со значениями, которые мы передаем, она не должна ссылаться на глобальное состояние.

2. method signature honesty
Во-вторых, сигнатура математической функции должна передавать всю информацию о возможных входных значениях, которые она принимает, и о возможных результатах, которые она может дать. Можно называть эту черту честность сигнатуры метода (method signature honesty)
Пример
Метод Divide, несмотря на то, что он ссылочно прозрачный, не является математической функцией. В его сигнатуре указано, что он принимает любые два целых числа и возвращает другое целое число. Но что произойдет, если мы передадим ему 1 и 0 в качестве входных параметров?

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/45c/f4d/fb6/45cf4dfb6d7cef3c2335f2ee1e933203.png)

Вместо того, чтобы вернуть целое число, как мы ожидали, он вызовет исключение «Divide By Zero». Это означает, что сигнатура метода не передает достаточно информации о результате операции. Он обманывает вызывающего, делая вид, что может обрабатывать любые два параметра целочисленного типа, тогда как на практике он имеет особый случай, который не может быть обработан.

## Отличия от ООП и процедурного стиля
**ООП**
В объектно-ориентированном программировании (ООП) вы создаете «объекты» (отсюда и название), которые представляют собой структуры, содержащие данные и методы. В функциональном программировании все является функцией. **Функциональное программирование пытается разделить данные и поведение, а ООП объединяет эти концепции**.

**Процедурный стиль**
В процедурном решении программа разбита на подпрограммы, изменяющие состояние вместо возврата значения

Функциональное решение читается хорошо, если разработчик в принципе знаком с таким стилем. Читаемость кода — важная характеристика, поэтому при небольшом объеме входных данных можно выбирать такой вариант.

Процедурное решение читается достаточно тяжело: нужно буквально выполнять код в уме. Еще в такой код сложнее вносить изменения — он слишком специфичен и завязан на текущую задачу. А еще нужно помнить, что процедура `filter_and_sort()` модифицирует свой аргумент.

Зато процедурный код работает эффективно и предсказуемо. Если у вас много данных с небольшим количеством повторов, то этот вариант может оказаться предпочтительным.
