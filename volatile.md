---
tags: Java/Многопоточность
---
Операции над переменными типа `volatile` в Java обеспечивают гарантированную **видимость изменений этой переменной между потоками**. Это означает, что когда один поток записывает значение в `volatile` переменную, все остальные потоки увидят это изменение.
[[volatile java объяснение.png]]
>[!Warning] Переменная volatile находится в хипе, а не в кэше стека!

## Кэширование переменных разными потоками
Возможна ситуация, когда один поток изменил значение переменной, а второй НЕ увидел этого изменения, потому что работал со своей, кэшированной копией переменной.

## Операции чтения и записи полей long и double не являются атомарными
![[Атомарность long, double.png]]

Например, если в одном потоке меняешь значение переменной int, а в другом потоке читаешь значение этой переменной, то получишь либо ее старое значение, либо новое — то, которое получилось после изменения в потоке 1. Никаких «промежуточных вариантов» там появиться не может. Однако с long и double это не работает (64 бита).

Почему? Из-за кроссплатформенности! https://youtu.be/ShzQJUFzq58?t=3014

>[!Note]+ Пояснение
>
>long и double — самые «тяжеловесные» примитивы в Java:
они весят по 64 бита. И в некоторых 32-битных платформах просто не реализована атомарность чтения и записи 64-битных переменных.
Такие переменные читаются и записываются в две операции.
Сначала в переменную записываются первые 32 бита, потом еще 32. Соответственно, в этих случаях может возникнуть проблема.
Один поток записывает какое-то 64-битное значение в переменную Х, и делает он это «в два захода». В то же время второй поток пытается прочитать значение этой переменной, причем делает это как раз посередине, когда первые 32 бита уже записаны, а вторые — еще нет.
В результате он читает промежуточное, некорректное значение, и получается ошибка.

Если мы объявляем в программе какую-то переменную, со словом volatile, это означает:
- Переменная всегда будет атомарно читаться и записываться (даже если это 64- битные double или long)
- Java-машина НЕ будет помещать ее в кэш. Так что ситуация, когда 10 потоков работают со своими локальными копиями исключена.

## Почему операции над volatile переменными не атомарны?
Однако операции над `volatile` переменными не являются атомарными. Атомарность означает, что операция выполняется в одном неделимом шаге, и она либо полностью выполняется, либо не выполняется вообще. В случае с `volatile` переменными операции чтения и записи могут быть атомарными, если они выполняются на переменных типа `long` или `double` (64 бита), поскольку они имеют гарантированную атомарность на уровне JVM. Однако операции чтения и записи на `volatile` переменных типа `int` или `boolean` (32 бита) не являются атомарными.

Это связано с тем, что многие процессорные архитектуры не поддерживают непосредственную атомарность операций на переменных размером более 32 бит. Для обеспечения атомарности операций над `volatile` переменными размером 64 бита (как `long` или `double`), JVM использует особые инструкции или блокировки на уровне процессора. Однако для переменных размером 32 бита (как `int` или `boolean`) такая поддержка может отсутствовать.

Если вам требуется атомарное выполнение операций над переменными, включая чтение и запись, вам следует использовать другие средства синхронизации, такие как `synchronized` блоки, `Lock` интерфейс или атомарные классы из пакета `java.util.concurrent.atomic`. [[Atomic типы данных]]
Эти средства обеспечивают атомарность операций над переменными и предотвращают [[Race condition|гонки данных]] в многопоточной среде.
