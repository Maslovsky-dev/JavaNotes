---
tags: SQL
--- 

> **B-дерево** (читается как Би-дерево) — это особый тип сбалансированного дерева поиска, в котором каждый узел может содержать более одного ключа и иметь более двух дочерних элементов. Из-за этого свойства B-дерево называют _сильноветвящимся_. 

![](https://lh5.googleusercontent.com/t-lKTImJk0YVIgr3aOSutejBYifvE8ef3VKniNKHzStbh4u5GeQQDBFnpV7oXaW-smkt7IupdgDZPebwp4bp6AHlF9S6j30JehSqX-yNIGJMCwYetPGuwcPZB5ySIxwQ8dNNdE7-)

## Зачем нужно

Вторичные запоминающие устройства (жесткие диски, SSD) медленно работают с большим объемом данных. Людям захотелось сократить время доступа к физическим носителям информации, поэтому возникла потребность в таких структурах данных, которые способны это сделать. 

Двоичное дерево поиска, АВЛ-дерево, красно-черное дерево и т. д. могут хранить только один ключ в одном узле. Если нужно хранить больше, высота деревьев резко начинает расти, из-за этого время доступа сильно увеличивается. 

С B-деревом все не так. Оно позволяет хранить много ключей в одном узле и при этом может ссылаться на несколько дочерних узлов. Это значительно уменьшает высоту дерева и, соответственно, обеспечивает более быстрый доступ к диску.

## Свойства 

1. Ключи в каждом узле `x` упорядочены по неубыванию.
2. В каждом узле есть логическое значение `x.leaf`. Оно истинно, если `x` — лист.
3. Каждый узел, кроме корня, содержит не менее `t-1` ключей, а каждый внутренний узел имеет как минимум `t` дочерних узлов, где `t` — _минимальная степень_ B-дерева.
4. Все листья находятся на одном уровне, т. е. обладают одинаковой глубиной, равной высоте дерева. 
5. Корень имеет не менее 2 дочерних элементов и содержит не менее 1 ключа.

## Операции с B-деревом

### Поиск элемента

> **Средняя временная сложность:** Θ(log n)  
> **Худшая временная сложность:** Θ(log n)

Поиск ключа в B-дереве работает так же, как и в двоичном дереве поиска. 

1. Сравниваем `k` с первым ключом узла, начиная с корня. Если `k = первый ключ узла`, возвращаем узел и индекс. 
2. Если `k.leaf = true`, возвращаем `NULL`. Элемент не найден.
3. Если `k < первый ключ корня`, рекурсивно ищем левый дочерний элемент этого ключа.
4. Если в текущем узле более одного ключа и `k > первый ключ`, сравниваем `k` со следующим ключом в узле.  
    Если `k < следующий ключ`, ищем левый дочерний элемент этого ключа (k находится между первым и вторым ключами).  
    Иначе иначе ищем правый дочерний элемент ключа.
5. Повторяем шаги с 1 по 4, пока не дойдем до листа.

### Пример
- Хотим найти ключ k = 17 в этом дереве.

![|400](https://lh5.googleusercontent.com/OP9d1SzMciCIZX9J0SiwAtNeWfcqhhXGo-r-8e3RvdafKQ0Bcq2WN1J3KaMaPPkxlxYz9hEFj-7lkHGw-LlXX3M0izqhNF-1XmMX3oANfPk-gpQY9khKOY9caMAqNoIa98HgA02o)

- k нет в корне → сравниваем k с ключом корня.

![|400](https://lh6.googleusercontent.com/_dPujGQI-uXdJhg-BTqN4sQTc2F6hUBrOvwvViHdiI1smKd4WmhFcdB6GNhMr1BzccDoO2KMUjaSSZb9qQNkfIxbZEShTpSHVrlY1djQBYKYstIVRftIS00l1OVEZGF33n5wYYBo)

- k > 11 → идем через правого «ребенка».

![|400](https://lh5.googleusercontent.com/9lKaZ9A0W6CKRIEtUgknlSN8c38u-12y3w4RLLKs3CrEkyb_9hrzUI9DrAqHaYBfX56sTeUE_RFcLhsC7f_JWyML2g3Yl9LOxAHaU1d1o5_eRWf5_vPWr8Ev8nyml5kxsUJ_99ky)

- Сравниваем k с первым ключом узла: k > 16 → сравниваем k со вторым ключом узла. 

![|400](https://lh4.googleusercontent.com/ku9DexpTH5yCPUTh6qzKeYh1T-OHXaDlf06AV0yaTC4AdTSKmCJnRZqk5AAlUCjBNHJBqLfmiCGsnmSBrh9YSDcZbpezzLyLYZ_0w1uNS1CHZmkhmbrD-9ik9ch4glia7QEWGOEm)

- k > 18 → k лежит между 16 и 18. Ищем либо в правом «ребенке» 16, либо в левом «ребенке» 18.

![|400](https://lh4.googleusercontent.com/Z1C02zLKycw6wLEMrShl1jDlhRFkSI4DxXzqQBfq0H5iR_gkMkgaYb6maM-QlQzAB4WPF0SvQCxmmmWBvzsXlygrxC7EA92MDLHyrbfOlrqX1G-1vZHkAHN4m_C2g5en1dE5KoSZ)

- Нашли 17.
