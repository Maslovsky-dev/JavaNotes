---
aliases: композиция и наследования
tags: Java/ООП
---

[Отношения между классами - Java программирование | ExamClouds](https://www.examclouds.com/ru/java/java-core-russian/class-relations#:~:text=%D0%90%D0%B3%D1%80%D0%B5%D0%B3%D0%B0%D1%86%D0%B8%D1%8F%20%D0%B8%20%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D1%8F%20%D1%8F%D0%B2%D0%BB%D1%8F%D1%8E%D1%82%D1%81%D1%8F%20%D1%87%D0%B0%D1%81%D1%82%D0%BD%D1%8B%D0%BC%D0%B8,%D0%BD%D0%B5%20%D0%BC%D0%BE%D0%B6%D0%B5%D1%82%20%D0%BF%D1%80%D0%B8%D0%BD%D0%B0%D0%B4%D0%BB%D0%B5%D0%B6%D0%B0%D1%82%D1%8C%20%D0%B4%D1%80%D1%83%D0%B3%D0%BE%D0%BC%D1%83%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%83.)
## 1. IS-A отношения

В ООП принцип IS-A основан на ==наследовании== классов или реализации интерфейсов. Например, если класс `HeavyBox` наследует `Box`, мы говорим, что `HeavyBox` является `Box` (`HeavyBox` IS-A `Box`). Или другой пример - класс `Lorry` расширяет класс `Car`. В этом случае `Lorry` IS-A `Car`.

То же самое относится и к реализации интерфейсов. Если класс `Transport` реализует интерфейс `Moveable`, то они находятся в отношении `Transport` IS-A `Moveable`.

## 2. HAS-A отношения

HAS-A отношения основаны на использовании. Выделяют три варианта отношения HAS-A: **ассоциация, агрегация и композиция.**

## Ассоциация
В этих отношениях объекты двух классов могут ссылаться друг на друга. Например, класс `Horse` HAS-A `Halter` если код в классе `Horse` содержит ссылку на экземпляр класса `Halter`:
```java
public class Halter {}
```

```java
public class Horse{
   private Halter halter;
}
```

## Агрегация и композиция
Агрегация и композиция являются частными случаями ассоциации. Агрегация - отношение когда один объект является частью другого. А композиция - еще более тесная связь, когда объект не только является частью другого объекта, но и вообще не может принадлежать другому объекту. Разница будет понятна при рассмотрении реализации этих отношений.

## Агрегация от лат. aggrego «присоединяю»
Объект класса `Halter` создается извне `Horse` и передается в конструктор для установления связи. Если объект класса `Horse` будет удален, объект класса `Halter` может и дальше использоваться, если, конечно, на него останется ссылка:

```java
public class Horse {
    private Halter halter;

    public Horse(Halter halter) {
        this.halter = halter;
    }
}
```

### Вложенные классы
>[!Note]
>Агрегация предполагает отношение "часть-целое", где вложенный класс является частью внешнего класса, но может существовать и независимо от него.

```java
class OuterClass {
    private int outerField;
    private InnerClass innerClass;

    public OuterClass() { //конструктор внешнего класса
        innerClass = new InnerClass();
    }

    // Вложенный класс - агрегация
    class InnerClass {
        private int innerField;
    }
}
```
## Композиция

Теперь посмотрим на реализацию композиции. Объект класса `Halter` создается в конструкторе, что означает более тесную связь между объектами. Объект класса `Halter` не может существовать без создавшего его объекта `Horse:`

```java
public class Horse {
    private Halter halter;

    public Horse() {
        this.halter = new Halter();
    }
}
```

### Вложенные классы
>[!Note]
>Композиция предполагает более сильное отношение "часть-целое", где вложенный класс является неразрывной частью внешнего класса, и он не может существовать без внешнего класса.

```java
class Car {
    private Engine engine;

    public Car() {
        engine = new Engine();
    }

    // Вложенный класс - композиция
    class Engine {
        private int horsepower;
    }
}
```
