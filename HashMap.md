---
tags: Java/Коллекции
---

HashMap<K,V> - это КЛАСС в Java коллекции интерфейсов и классов (Java Collection Framework), который реализует interface Map<K,V> ( пары ключей и значений (key & value)):
- КЛЮЧИ элементов должны быть уникальными (и IMUTEABLE), может быть null.
- ЗНАЧЕНИЯ элементов могут повторяться. Значение может быть null.

В основе HashMap лежит массив. Элементы данного массива являются структуры LinkedList. Данные структуры LinkedList и заполняются элементами, которые мы добавляем в HashMap
>[!Note]+
>HashMap НЕ запоминает порядок добавления элементов в коллекцию.
НЕ синхронизируемая! Нельзя использовать в условиях многопоточности, для этого есть [[ConcurrentHashMap]].

**Почему так популярен?** HashMap быстро работает, и большинство операций выполняется за фиксированное или константное O(1) время благодаря оптимизированному доступу к данным.
## HashTable
Устаревший класс, который работает по тем же принципам, что и HashMap
В отличие от НаshMap является Synchronized. По этой причине его методы далеко не такие быстрые
## Словарь терминов
**Хеш-таблица** – это структура данных, реализующая интерфейс ассоциативного массива (абстрактная модель «ключ – значение» или entry), которая обеспечивает очень быструю вставку и поиск: независимо от количества элементов вставка и поиск (а иногда и удаление) выполняются за время, близкое к константе – O(1).

**Хеш-функция** hashCode() задаёт связь между значением элемента и его позицией в хеш- таблице.

**Table** — массив типа Entry[] (вход), который является хранилищем для элементов корзин/бакетов (хранящих ссылки на списки/цепочки значений).

**Size** — Количество нод/узлов HashMap-а (не путать с ёмкостью массива).

**Capacity** – это ёмкость созданного массива Entry[], значение по умолчанию 16 элементов (идентификатор от 0 до 15 мест для корзин или бакетов). Укажем больше, будет больше.

**Корзины или бакеты** («buckets») – это элементы массива (ячейки), которые используются для хранения отдельно взятых узлов (или цепочек узлов).

Внутри каждой ячейки массива (корзины или бакета) лежит односвязный список LinkedList, либо лежит красное-черное дерево при перестроении (класс TreeMap).
Максимальная длина связанного списка – цепочка узлов из 8 значений.

**Узел** представляет собой объект вложенного (в класс HashMap) класса Node (или TreeNode при древовидной структуре), имплементирует интерфейс Map.Entry<K,V>, содержит поля: hash, key, value, next.

**LoadFactor** — коэффициент загрузки. Значение по умолчанию 0.75 является хорошим компромиссом между временем доступа и объемом хранимых данных;
Чем больше LoadFactor, тем больше экономия памяти под массив, но поиск элемента будет занимать также больше времени.

Вы можете указать свои емкость и коэффициент загрузки, используя конструкторы HashMap(capacity) и HashMap(capacity, loadFactor). Максимальная емкость, которую вы сможете установить, равна половине максиального значения int. Почему?
Тип данных хэш-кода.

**Threshold** — предельное количество элементов, при достижении которого, размер хэш- таблицы увеличивается вдвое, рассчитывается по формуле (capacity * loadFactor).

## Структура
В основе HashMap лежит массив.
Элементами этого массива являются структуры односвязного списка LinkedList, которые заполняются элементами.
![[Структура HashMap Img.png]]

При помещении нового элемента (k/v), ищется нужная корзина.
Если в корзине пусто, то помещаем туда новый объект.

Если занято, то находим нужную корзину и проверяем первый объект, который там лежит.
- Если такой элемент в цепочке существует, его значение перезаписывается.
- Если место занято и объект не совпадает с нашим, то размещаем наш объект в следующем узле (она же нода, она же entry) в цепочке списка одной корзины (см. №3), для добавления нового узла/ноды будет вызван метод addEntry()

Нода содержит поля и хранит инфо: hash, key, value, next (ссылка на следующий узел).

### Что может быть ключом?
В Java, ключом в `HashMap` может быть любой объект, который правильно реализует методы `hashCode()` и `equals()`. Вот некоторые общие типы, которые могут использоваться в качестве ключей:

1. Встроенные типы данных: Встроенные типы данных, такие как `Integer`, `String`, `Boolean`, `Character`
2. Пользовательские классы
3. Перечисления (`enum`)
``` java
enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

HashMap<Day, String> map = new HashMap<>();
map.put(Day.MONDAY, "Значение 1");
map.put(Day.TUESDAY, "Значение 2");
```

### Хэш код
Перед тем, как сделать что-то с объектом вычисляется его НОВЫЙ хэш-код. Для генерации используется метод hash(hashCode), в который передается key.hashCode()
>[!INFO] Формула расчёта ХЭШ-КОДА для ключа:
> (hashCode) ^ (hashCode >>> 16) побитовый сдвиг на 16

Почему бы просто не вычислить код с помощью hashCode()?
Это сделано из-за того, что hashCode() можно реализовать так, что только нижние биты int'a будут заполнены. Например, для Integer, Float – если мы в HashMap кладем маленькие значения, то у них и биты хеш-кодов будут заполнены только нижние. В таком случае ключи в HashMap будут иметь тенденцию скапливаться в нижних ячейках, а верхние будут оставаться пустыми, что не очень эффективно.

На то, в какой бакет попадёт новая запись, влияют только младшие биты хеша. Поэтому и придумали различными манипуляциями подмешивать старшие биты хеша в младшие, чтобы улучшить распределение по бакетам (чтобы старшие биты родного хеша объекта начали вносить коррективы в то, в какой бакет попадёт объект) и, как следствие, производительность. Потому и придумана дополнительная функция hash внутри HashMap.

>[!EXAMPLE]+ Пример
>![[Пример hashCode в hashMap.png|500]]
>При значении хэша 51 и размере таблицы 16, мы получаем индекс корзины в массиве:
Эта формула применяется и для определения бакета при добавлении элемента и для поиска бакета, когда пытаемся достать элемент (пару k/v).
**Вопрос**: как узнать, в какую корзину попадёт элемент, если значение его хэш-кода 51?
Ответ: остаток от деления на кол-во корзин (т.к. 51 % 16 = 3 (проверка 3 * 16 = 48 + 3))

## Как происходит сравнение при добавлении элемента? Или при поиске
Рассчитав и зная индекс в массиве, мы получаем список (цепочку) элементов, привязанных к этой корзине (ячейке). Хэш и ключ нового элемента поочередно сравниваются с хэшами и ключами элементов из списка и, при совпадении этих параметров, значение элемента перезаписывается.

Сравниваем КЛЮЧ нашего объекта с первым в цепочке объектом:
- проверка по хэш-коду
- ссылочное сравнение
- если предыдущий пункт выдал false, то проверка на equals

Сравнение ключей при добавлении HashMap
```java
if (e.hash == hash && (e.key == key || key.equals(e.key))) { 
	//Такой ключ уже содержится в Map
	V oldvalue = e.value; // Получаем старое значение
	e.value = value; // Заменяем старое значение на новое
	return oldvalue; //Возвращаем старое значение
}
```


>[!tip] Где используется equals при добавлении объекта в мапу?
>В самом конце сравнения, т.к. equals - дорогая операция

Если же предыдущий шаг не выявил совпадений, будет вызван метод **addEntry(hash, key, value, index)** для добавления нового элемента.



>[!WARNING]+ Если при добавлении в качестве ключа передан null
> Будет вызван метод putForNullKey(value), внутри которого нет вызова методов hash() и indexFor() (потому как все элементы с null-ключами всегда помещаются в корзину[0]), но есть такие действия:
>
Все элементы цепочки, привязанные к **корзине[0]**, поочередно просматриваются в поисках элемента с ключом null.
Если такой элемент в цепочке существует, его значение перезаписывается.
Если элемент с ключом null не был найден, будет вызван уже знакомый метод addEntry().

## Когда и как происходит перестроение мапы в дерево?
Первоначальный размер HashMap = 16 бакетов.
Когда массив заполняется на 75%, то есть заполняются 12/16 бакетов (loadFactory = 0,75), размер массива увеличивается в 2 раза, т.е. становится 32 бакета.

И так далее (64, 128 …). При увеличении размера массива все объекты, уже содержащиеся в HashMap, будут перераспределены по новым бакетам, с учётом их нового количества.

Каждый бакет содержит в себе ноды (пары ключ-значение), когда нодов становится 8, а бакетов 64, то структура Node перестраивается в красно-черное дерево (TreeNode).

Обратное перестроение TreeNode →Node случается, если количество нод в цепочке <6
- [ ] В дереве как элементы сравниваются между собой? По hashCode?

Протестировать визуализацию дерева https://www.cs.usfca.edu/~galles/visualization/RedBlack.html

## Производительность HashMap
![[Производительность HashMap.png]]
Красная зона – ужасно O(n^2); O(2^n); O(n!) Оранжевая – плохо: O(n log n)
Жёлтая – справедливо, оправдано: O(n) или линейное время Салатовый – хорошо O(log n) Зелёный – превосходно! О(1) или константа

Сравнение производительности разных коллекций по ссылке (аккуратно, можно зависнуть): https://www.bigocheatsheet.com/

![[Сравнение производительности коллекций.png]]

### Сложность основных операций HashMap
Для вставки элемента HashMap.put()
1. Вычисляется хэш ключа. Если ключ null, хэш считается равным 0. Чтобы достичь лучшего распределения, результат вызова hashCode() «перемешивается»: его старшие
биты XOR-ятся на младшие. XOR (^) – это математический оператор. Применяется к логическим операциям.
2. Значения внутри хэш-таблицы хранятся в специальных структурах данных – нодах, в массиве. Из хэша высчитывается номер бакета – индекс для значения в этом массиве.
Полученный хэш обрезается по текущей длине массива. Длина – всегда степень двойки, так что для скорости используется битовая операция &.
3. В бакете ищется нода. В ячейке массива лежит не просто одна нода, а связка всех нод, которые туда попали. Исполнение проходит по этой связке (цепочке или дереву), и ищет ноду с таким же ключом. Ключ сравнивается с имеющимися сначала на == , затем
на equals.
4. Если нода найдена – её значение просто заменяется новым.
Работа метода на этом завершается.
5. Если ноды с таким же ключом в бакете пока нет – добавляемая пара ключ- значение запаковывается в новый объект типа Node, и прикрепляется к структуре существующих нод бакета. Ноды составляют структуру за счет того, что в ноде хранится ссылка на следующий элемент (для дерева – следующие элементы). Кроме самой пары и ссылок, чтобы потом не считать заново, записывается и хэш ключа.
6. В случае, когда структурой была цепочка а не дерево, и длина цепочки превысила 7 элементов – происходит процедура treeification – превращение списка в самобалансирующееся дерево. В случае коллизии это ускоряет доступ к элементам на чтение с O(n) до O(log(n)). У comparable-ключей для балансировки используется их естественный порядок. Другие ключи балансируются по порядку имен их классов и значениям identityHashCode-ов. Для маленьких хэш-таблиц (< 64 бакетов) «одеревенение» заменяется увеличением (см. п.8).
7. Если новая нода попала в пустую ячейку, заняла новый бакет – увеличивается счетчик структурных модификаций. Изменение этого счетчика сообщит всем итераторам контейнера, что при следующем обращении они должны
выбросить ConcurrentModificationException.
8. Когда количество занятых бакетов массива превысило пороговое (capacity * load factor), внутренний массив увеличивается вдвое, а для всего содержимого выполняется рехэш – все имеющиеся ноды перераспределяются по бакетам по тем же правилам, но уже с учетом нового размера.

Закрепление и самопроверка [Java Interview Review – подготовка к собеседованиям Java](https://itsobes.ru/JavaSobes/tags/kollektsii/)
![[HashMap повторить.png]]
