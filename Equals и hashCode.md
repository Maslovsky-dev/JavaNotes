---
aliases: hashCode, equals, хэшкод
tags: Java/ООП
---
## Hash code
Хеш-код — это «цифровой отпечаток», целочисленный результат работы метода, которому в качестве входного параметра передан объект.

Хэш — это числовой отпечаток объекта, мета-инфо о состоянии объекта), некоторое число, генерируемое на основе объекта и описывающее его состояние в какой-то момент времени.
### Переопределение hashCode для базовых типов данных (Строки, целочисленные и вещественные числа)
[Как сгенерировать hashCode в Java « SEOstella.com](http://www.seostella.com/ru/article/2012/10/04/kak-sgenerirovat-hashcode-v-java.html)
- 1. Присвойте результирующей переменной (result) некоторое ненулевое простое число (например, 17)
- 2. Если поле value имеет тип boolean, вычислите (value ? О : 1)
- 3. Если поле value имеет тип byte, char, short или int, вычислите (int)value
- 4. Если поле value имеет тип long, вычислите (int)(value - (value >>> 32))
- 5. Если поле value имеет тип float, вычислите Float.floatToIntBits(value)
- 6. Если поле value имеет тип double, вычислите Double.doubleToLongBits(value), а затем преобразуйте полученное значение, как указано в п.4
- 7. Если поле value является ссылкой на объект, вызывайте метод hashCode() этого объекта
- 8. Если поле value является ссылкой на объект и равно null, используйте число 0 для представления его хэш-кода
- 9. Объедините полученные в п. 2 - п. 8 значения следующим образом: 37*result + value
- 10. Если поле является массивом, примените правило 9 для каждого элемента массива
- 11. Проверьте, что равные объекты возвращают одинаковый hashCode

Для базовых типов данных, таких как строки, целочисленные и вещественные числа, Java уже предоставляет реализацию метода hashCode(). Например, для строк используется алгоритм djb2:

```java
public int hashCode() {
    int hash = 5381;
    for (int i = 0; i < length(); i++) {
        hash = ((hash << 5) + hash) + charAt(i);
    }
    return hash;
}
```


## Вопросы

### Для чего нужен метод hashCode?
**Метод hashCode() – это ПРИКИДКА**: объекты возможно равны? Если ок, то вызываем equals() для ТОЧНОГО сравнения. Разные коды, следовательно содержание разное.

### Какие поля следует использовать при подсчете hashCode()?
Выбирать поля, которые с большой долей вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как id, uuid. При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().

### Могут ли у разных объектов быть одинаковые hashCode?
Да. Ситуация, когда у разных объектов одинаковые хэшкоды, называется **коллизией**.
Вероятность возникновения коллизии зависит от используемого алгоритма генерации хэш-кода.

### Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?
В Java множество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено. Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть.

### Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y
Множитель создает зависимость значения хэш-кода от очередности обработки полей, а это дает гораздо лучшую хэш-функцию.

Алгоритм доступно и близко к практике (работа с данными) https://youtu.be/lWnzRILIEZ0

## Equals
Equals – это метод, определенный в Object, который служит для сравнения СОСТОЯНИЯ объектов.
- При сравнении объектов при помощи == сравниваются ссылки
- При сравнении по equals() сравниваются состояния объектов

При переопределении equals() обязательно нужно переопределить метод hashCode().
Равные объекты должны возвращать одинаковые хэш коды.


### Зачем нужен equals(). Чем он отличается от операции ==
Обычное сравнение двух объектов через оператор == — это плохая идея, потому что знак == сравнивает ссылки.

Пример: ссылки car1 и car2 указывают на разные адреса в памяти, поэтому они не равны. Но мы хотим сравнить два объекта, а не две ссылки и лучшее решение для сравнения объектов — это метод equals().

### Контракт equals
(переопределяя метод equals(), обязательно соблюдай контракт).
Это не просто набор каких-то «полезных рекомендаций», а именно жесткий контракт методов, прописанный в документации Oracle.
![[Контракт equals.png]]
![[Пример equals.png]]


## Контракт между equals и hashCode
![[контракт между hashCode и equals.png]]

## Переопределение equals и hashCode
[[Переопределение Java#Переопределение методов equals и hash code|Переопределение equals и hashCode]]
