---
tags: Spring/Web
aliases: DispatcherServlet, WebApplicationContext
---
Паттерн Front Controller обеспечивает единую точку входа для всех входящих запросов.

В Spring в качестве Front Controller выступает DispatcherServlet, все действия проходят через него. Как правило, в приложении задаётся только один DispatcherServlet с маппингом “/”, который перехватывает все запросы.

**Это и есть реализация паттерна Front Controller.**

Все запросы обрабатываются ОДНИМ фрагментом кода, который затем может делегировать ответственность за обработку запроса другим объектам приложения.

Он также обеспечивает интерфейс для общего поведения, такого как безопасность, интернационализация и передача определенных представлений определенным пользователям.

>[!INFO]
Однако иногда необходимо определить два и более **DispatcherServlet**-а, которые будут отвечать за свой собственный функционал. Например, чтобы один обрабатывал REST- запросы с маппингом “/api”, а другой обычные запросы с маппингом “/default”.

## Несколько контекстов
Spring может иметь НЕСКОЛЬКО КОНТЕКСТОВ одновременно. Одним из них будет **корневой** контекст, а все остальные контексты будут **дочерними**.
![[Наследование контекстов Spring.png|400]]

Все **дочерние** контексты могут получить ДОСТУП К БИНАМ, определенным в **корневом** контексте, но НЕ наоборот.

Корневой контекст НЕ может получить доступ к бинам дочерних контекстов.

Каждый дочерний контекст внутри себя может переопределить бины из корневого контекста.

Каждый **DispatcherServlet** имеет свой дочерний контекст приложения. **DispatcherServlet** расширяет **HttpServlet**, основной целью которого является обработка входящих веб-запросов, соответствующих настроенному шаблону URL.
>Он принимает входящий URI и находит правильную комбинацию контроллера и вида.
Веб-приложение может определять любое количество **DispatcherServlet**-ов. Каждый из них будет работать в своем собственном пространстве имен, загружая свой собственный дочерний **WebApplicationContext** (на рисунке - Servlet WebApplicationContext) с вьюшками, контроллерами и т.д.

Например, когда необходимо в одном **Servlet WebApplicationContext** определить обычные контроллеры, а в другом REST-контроллеры.

WebApplicationContext расширяет **ApplicationContext** (создаёт и управляет бинами и т.д.), но помимо этого он имеет дополнительный метод getServletContext(), через который у него есть возможность получать доступ к ServletContext-у.

ContextLoaderListener создает корневой контекст приложения
(на рисунке - Root WebApplicationContext) и будет использоваться всеми дочерними контекстами, созданными всеми DispatcherServlet.

Корневой контекст приложения будет общим и может быть только один.
**Root WebApplicationContext** содержит компоненты, которые видны всем дочерним контекстам, такие как сервисы, репозитории, компоненты инфраструктуры и т.д.

После создания корневого контекста приложения он сохраняется в ServletContext
как атрибут, имя которого: `WebApplicationContext.class.getName() + ".ROOT"`

Чтобы из контроллера любого дочернего контекста обратиться к корневому контексту приложения, можно использовать класс WebApplicationContextUtils, содержащий статические методы ![[WebAplicationContextUtils.png|350]]

**ContextLoaderListener создает корневой контекст приложения.**
![[ContextLoaderListener.png]]
