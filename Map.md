---
tags: Java/Коллекции
---
Отображение или ассоциативный массив. Не наследуется от коллекции, но тоже является коллекцией.
Можно индексировать объекты любыми объектами
![[Реализации Map.png]]
[[Методы и обход Map.png]]
## [[HashMap]]

## LinkedHashMap
Реализация LinkedHashMap отличается от HashMap поддержкой двухсвязного списка, определяющего порядок итерации по элементам структуры данных.
По умолчанию элементы списка упорядочены согласно их порядку добавления в LinkedHashMap (insertion-order). Однако порядок итерации можно изменить, установив параметр конструктора accessOrder в значение true. В этом случае доступ осуществляется по порядку последнего обращения к элементу (access-order).

>[!Note] Элемент LinkedHashMap помимо той информации, которую содержит элемент HashMapa еще содержит ссылку на предыдущий и предшествующий элемент

Это означает, что при вызове методов get() или put() элемент, к которому обращаемся, перемещается в конец списка.

При добавлении элемента, который уже присутствует в LinkedHashMap (т.е. с одинаковым ключом), порядок итерации по элементам не изменяется.

>[!INFO] Порядок в HashMap не гарантируется, в отличие от LinkedHashMap).
>Поля и конструктор (capacity, loadFactor, order).
Класс несинхронизированный (многопоточность не поддерживает).

[[Порядок элементов LinkedHashMap.png]]
![[Порядок по доступу LinkedHashMap.png|400]]

## TreeMap
- TreeMap имеет все методы, которые есть у **HashMap**, такие как put, get, remove, containsKey, containsValue и т.д.

Под капотом TreeMap [[Красно черное дерево]] для хранения данных в отсортированном виде с возможностью быстрого поиска + имплементируются интерфейсы NavigableMap, SortedMap добавляя функционал, которого нет в HashMap:
- Хранение данных в структурированном виде с возможностью навигации.
- Дополнительные методы: firstKey, lastKey, lowerKey, higherKey, ceilingKey, floorKey, subMap, headMap, tailMap и т.д. Эти методы позволяют получать ключи или подмапы по определенным критериям или диапазонам.

[[Null в TreeMap]]

## WeakHashMap
[[Другие реализации Map.png]]
[[Пример WeakHashMap.png]]

**WeakHashMap** — это структура данных, реализующая интерфейс Map и основанная на использовании [[Виды ссылок в java|WeakReference]] для хранения ключей.
Таким образом, пара «ключ-значение» будет удалена из WeakHashMap, если на объект- ключ более не имеется сильных ссылок.

**Основная разница между HashMap и WeakHashMap** заключается в том, как они обрабатывают ключи, на которые больше нет сильных ссылок. В HashMap ключи остаются в памяти до тех пор, пока явно не будут удалены из карты или до тех пор, пока сама карта не будет удалена. Сборщик мусора не может удалить такие ключи, даже если они больше не используются в программе.
>[!NOTE] Где может применяться?
>WeakHashMap часто используется в ситуациях, где требуется временное или кэшированное хранение данных, и эти данные должны быть автоматически удалены, когда на них больше нет активных ссылок.
## Разница между HashMap, TreeMap, и Hashtable

Есть три основных воплощения интерфейса [Map](https://docs.oracle.com/javase/7/docs/api/java/util/Map.html) в Java: [HashMap](https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html), [TreeMap](https://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html), и [Hashtable](https://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html). Главные отличия заключаются в следующем:

- **Порядок прохода**. [HashMap](https://javarush.com/groups/posts/732-kak-rabotaet-hashmap-v-java) и HashTable не дают гарантий по упорядоченности в Map; в частности, они не гарантируют что порядок останется тем же самым в течении времени. Но `TreeMap` будет упорядочивать все значения в "естественном порядке" ключей или по компаратору.
- **Допустимые пары ключ-значение.** `HashMap` **позволяет иметь ключ null и значение null**. `HashTable` не позволяет ключ null или значение null. Если `TreeMap` использует естественный порядок или компаратор не позволяет использовать ключ null, будет выброшено исключение.
- **Синхронизация**. Только `HashTable` синхронизирована, остальные — нет. Но, "если потокобезопасное воплощение не нужно, рекомендуется использовать `HashMap` вместо `HashTable`".
![[Сравнительная таблица реализаций Map.png]]
## Что будет если
### Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), но для которых equals() == false?
По значению hashCode() вычисляется индекс ячейки массива, в список которой этот элемент будет добавлен. Перед добавлением осуществляется проверка на наличие элементов в этой ячейке. Если элементы с таким hashCode() уже присутствует, но их
equals() методы не равны, то элемент будет добавлен в конец списка.
### Что будет, если мы кладем в HashMap ключ, у которого equals и hashCode определены некорректно?
### Возможна ли ситуация, когда HashMap выродится в список даже с ключами имеющими разные hashCode()

Это возможно в случае, если метод, определяющий номер корзины будет возвращать одинаковые значения.
### Почему нельзя использовать byte[] в качестве ключа в HashMap?
Хэш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хэш-кода массива не переопределен и вычисляется по стандартному Object.hashCode() на основании адреса массива). Также не переопределен метод equals для массивов
### Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?
Да, будет, но в этом случае HashMap вырождается в связный список и теряет свои преимущества.

### Какое худшее время работы метода get(key) для ключа, которого НЕТ/ЕСТЬ в HashMap?

O(N). Худший случай – это поиск ключа в HashMap, вырожденного в список по причине совпадения ключей по hashCode(). Для выяснения хранится ли элемент с определенным ключом может потребоваться перебор всего списка.
