Прототип — это порождающий паттерн проектирования, который позволяет **копировать объекты,** не вдаваясь в подробности их реализации.

**Проблема**

У вас есть объект, который нужно скопировать. Как это сделать? Нужно создать пустой объект такого же класса, а затем поочерёдно скопировать значения всех полей из старого объекта в новый.
![[Прототип паттерн Img.png]]

Прекрасно, но есть нюанс. Не каждый объект удастся скопировать таким образом, ведь часть его состояния может быть приватной, а значит недоступной для остального кода.

Есть и другая проблема. Копирующий код станет зависим от классов копируемых объектов. Т.к., чтобы перебрать все поля объекта, нужно привязаться к его классу. Из-за этого нельзя копировать объекты, зная только их интерфейсы, а не конкретные классы.

**Решение**

Паттерн Прототип **поручает** создание копий самим копируемым объектам. Он вводит **общий интерфейс** для всех объектов, поддерживающих клонирование. Это позволяет копировать объекты, не привязываясь к их конкретным классам. Обычно такой интерфейс имеет **всего один метод** clone().

Реализация этого метода в разных классах очень схожа. Метод создаёт новый объект текущего класса и копирует в него значения всех полей собственного объекта. Так получится скопировать даже приватные поля, так как большинство языков программирования разрешает доступ к приватным полям любого объекта текущего класса.

Объект, который копируют, называется прототипом (отсюда и название паттерна). Когда объекты программы содержат сотни полей и тысячи возможных конфигураций, прототипы могут служить своеобразной альтернативой созданию подклассов.

В этом случае все возможные прототипы заготавливаются и настраиваются на этапе инициализации программы. Потом, когда программе нужен новый объект, она создаёт копию из приготовленного прототипа.

Наиболее понятный и близкий пример паттерна — деление клеток. После митозного деления клеток образуются две совершенно идентичные клетки. **Оригинальная клетка отыгрывает роль прототипа,** принимая активное участие в создании нового объекта.

Структура и псевдокод по ссылке → https://refactoring.guru/ru/design-patterns/prototype

## **Кода применять?**

1. Когда ваш код не должен зависеть от классов копируемых объектов.

Такое часто бывает, если ваш код работает с объектами, поданными извне через какой- то общий интерфейс. Вы не можете привязаться к их классам, даже если бы хотели, поскольку их конкретные классы неизвестны.

Паттерн прототип предоставляет клиенту общий интерфейс для работы со всеми прототипами. Клиенту не нужно зависеть от всех классов копируемых объектов, а только от интерфейса клонирования.

2. Когда имеете уйму подклассов, которые отличаются начальными значениями полей. Кто-то мог создать все эти классы, чтобы иметь возможность легко порождать объекты с определённой конфигурацией.

Паттерн прототип предлагает использовать набор прототипов, вместо создания подклассов для описания популярных конфигураций объектов.

Таким образом, вместо порождения объектов из подклассов, вы будете копировать существующие объекты-прототипы, в которых уже настроено внутреннее состояние. **Это позволит избежать взрывного роста количества классов** в программе и уменьшить её сложность.

## **Шаги реализации**

- Создайте интерфейс прототипов с единственным методом **clone**. Если у вас уже есть иерархия продуктов, метод клонирования можно объявить непосредственно в каждом из её классов. - Добавьте в классы будущих прототипов альтернативный конструктор, принимающий в качестве аргумента объект текущего класса. Этот конструктор должен скопировать из поданного объекта значения всех полей, объявленных в рамках текущего класса, а затем передать выполнение родительскому конструктору, чтобы тот позаботился о полях, объявленных в суперклассе.

Если ваш язык программирования не поддерживает перегрузку методов, то вам не удастся создать несколько версий конструктора. В этом случае копирование значений можно проводить и в другом методе, специально созданном для этих целей. Конструктор удобнее тем, что позволяет клонировать объект за один вызов.

- Метод клонирования обычно состоит всего из одной строки: вызова оператора new с конструктором прототипа. Все классы, поддерживающие клонирование, должны явно определить метод clone, чтобы использовать собственный класс с оператором new. В обратном случае результатом клонирования станет объект родительского класса. - Опционально, создайте центральное хранилище прототипов. В нём удобно хранить вариации объектов, возможно, даже одного класса, но по-разному настроенных.

Вы можете разместить это хранилище либо в новом фабричном классе, либо в фабричном методе базового класса прототипов. Такой фабричный метод должен на основании входящих аргументов искать в хранилище прототипов подходящий экземпляр, а затем вызывать его метод клонирования и возвращать полученный объект.

- Наконец, нужно избавиться от прямых вызовов конструкторов объектов, заменив их вызовами фабричного метода хранилища прототипов.
![[Преимущества и недостатки паттерна Прототип.png]]
## Пример реализации
Допустим, у нас есть класс `Shape`, который представляет фигуру, и у этого класса есть метод `clone()`, который используется для создания копии фигуры:

```java
// Абстрактный класс Shape
abstract class Shape implements Cloneable {
    private String type;

    public Shape(String type) {
        this.type = type;
    }

    public abstract void draw();

    // Метод клонирования объекта
    @Override
    public Shape clone() {
        Shape clone = null;
        try {
            clone = (Shape) super.clone(); // Вызывается метод clone() у класса Object
            //Далее происходит обратное преобразование в Shape
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return clone;
    }
}

// Конкретная реализация класса Shape
class Circle extends Shape {
    private int radius;

    public Circle(int radius) {
        super("Circle");
        this.radius = radius;
    }

    @Override
    public void draw() {
        System.out.println("Drawing a circle with radius " + radius);
    }
}

// Конкретная реализация класса Shape
class Rectangle extends Shape {
    private int width;
    private int height;

    public Rectangle(int width, int height) {
        super("Rectangle");
        this.width = width;
        this.height = height;
    }

    @Override
    public void draw() {
        System.out.println("Drawing a rectangle with width " + width + " and height " + height);
    }
}

// Клиентский код
public class Client {
    public static void main(String[] args) {
        Shape circle = new Circle(5);
        Shape rectangle = new Rectangle(10, 6);

        // Копирование объектов с помощью метода clone()
        Shape circleCopy = circle.clone();
        Shape rectangleCopy = rectangle.clone();

        circle.draw(); // Output: Drawing a circle with radius 5
        circleCopy.draw(); // Output: Drawing a circle with radius 5

        rectangle.draw(); // Output: Drawing a rectangle with width 10 and height 6
        rectangleCopy.draw(); // Output: Drawing a rectangle with width 10 and height 6
    }
}
```

>[!note]
>Если класс `Shape` наследуется от некоторого другого класса (допустим, назовем его `ParentClass`), то реализация метода `clone()` из предыдущего примера все равно будет работать, но есть одно важное условие: класс `ParentClass` **также должен реализовать интерфейс** `Cloneable` и переопределить метод `clone()`. Если родительский класс не реализует интерфейс `Cloneable` или не переопределяет метод `clone()`, то при попытке клонирования объекта класса `Shape` могут возникнуть проблемы.
