---
tags: Java/ООП
--- 
Методы (void) - действия, которые можно делать с данными объекта
[[Сигнатура и контракт метода]]
## Возвращение данных методами
Метод может возвращать определенный тип данный, например `int`.

Это значение может быть данными любого вида: как переменной простого типа, так и ссылочного. Слово `return` имеет прямое отношение к возвращаемому значению: значение, стоящее после него, будет отправлено назад, на место вызова метода, а сам же метод после `return` закроется. Это слово обычно идёт **в последней строке метода** (кроме методов с различными ветвлениями типа `if, else..`.). Если написать код в следующей строке после `return`:

```java
private String constructHelloSentence(String name) {
  String resultSentence = "Hello world! My name is " + name;
  return resultSentence;
}
```

## Перегрузка и переопределение
[[Перегрузка Java ]]
[[Переопределение Java]]

## Метод main
1. Точка входа: Метод `main` является точкой входа для запуска программы. Когда вы запускаете Java-приложение, виртуальная машина Java (JVM) ищет метод `main` в указанном классе и начинает выполнение программы с его вызова.
2. Модификаторы доступа и модификатор `static`: Метод `main` должен быть объявлен с модификатором доступа `public`, чтобы он мог быть доступен извне класса. Он также должен быть объявлен с модификатором `static`, что позволяет вызывать метод без создания экземпляра класса.
3. Параметр `args`: Параметр `args` представляет собой массив строк (`String[]`), который предоставляет аргументы командной строки, переданные при запуске программы. Вы можете использовать этот параметр для передачи дополнительной информации в программу при ее запуске.
4. Возвращаемый тип `void`: Метод `main` не возвращает никакого значения, поэтому его возвращаемый тип указывается как `void`.
5. Выполнение программы: Тело метода `main` содержит код, который будет выполнен при запуске программы. Здесь вы можете разместить основную логику вашей программы, вызывать другие методы, обрабатывать входные аргументы и т. д.
### Может ли быть несколько методов main?
Может, но выполняться будет только один, который указан при запуске.

Например, есть два класса:

**TestClass1.java**

```java
public class TestClass1{
    public static void main (String[] args){
        // 
    }
}
```

**TestClass2.java**

```java
public class TestClass2 {
    public static void main (String[] args){
        // 
    }
}
```
При компиляции будет создано два файла `TestClass1.class` и `TestClass2.class` (если будет два public класса в одном файле - компилятор выдаст ошибку `error: class TestClass2 is public, should be declared in a file named TestClass2.java`). А так как у нас будет создано два класса, то выполняться будет первым и единственным только тот `main`, который будет явно указан при старте:

Выполнение первого - `java TestClass1`

Выполнение второго - `java TestClass2`

В случае если у нас все упаковано в .jar файл, то там все равно должен быть указан `Main-Class`, метод `main` которого и будет запускаться
### Что если не будет ни одного метода main()
Веб сервер может сам выступать в роли метода main и сам запускать нужный код.
## Нативные методы
Реализуются на языке, отличном от Java (например С, С++...).
Плюсы: можно обратиться напрямую к операционной системе; возможность использования библиотек других языков, работать с памятью. Минусы: просадка производительности; теряется статическая типовая информация.
У нативных методов нет тела, также они содержат специальные ключевые слова
[В нативный код из уютного мира Java: путешествие туда и обратно (часть 1) / Хабр](https://habr.com/ru/company/jugru/blog/521672/)

## Дефолт методы
Применяются в интерфейсах, чтобы выполнять код, стандартный для всех классов, реализующих данный интерфейс. ДМ не требуют переопределения в классах и доступны всем объектам, реализующим данный интерфейс.

Чтобы метод, включенный в интерфейс, стал дефолтным необходимо использовать ключевое слово `default` в определении метода.
```java
public interface ComparePerimeter {
   //абстрактный метод
   double perimeter(); 
	//дефолтный метод
   default int comparePerimeters(ComparePerimeter figure){ 
       return Double.compare(perimeter(), figure.perimeter());
   };
}
```

