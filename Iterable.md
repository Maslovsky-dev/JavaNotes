---
tags: Java/Коллекции  
---
`java.lang.Iterable<E>` — интерфейс стандартной библиотеки Java. По объекту класса, реализующего этот интерфейс, можно "проитерироваться" — перечислить несколько элементов типа E, используя **for each** конструкцию

Интерфейс Iterable содержит один метод **iterator()**, возвращающий объект типа `Itaretor<E>`.
## Как связаны между собой Iterable, Iterator и for-each
### Интерфейс Iterable
`Interface Iterable<T>` – это интерфейс, который реализуют коллекции. У него есть метод **iterator()**, который возвращает объект Итератор по элементам типа T.
```java
public interface Iterable<T> {  
	Iterator<T> iterator();
	//...
```

>[!tip] Реализация ==Iterable== интерфейса позволяет объекту использовать цикл for-each. 
>Он делает это внутренне вызывая метод **iterator()**

### Интерфейс Iterator
`java.util.Iterator<E>` — интерфейс, описывающий свойства "итератора".

>[!Note] Итератор - объект с состоянием итерации (бегунок, курсор, указатель)

Итератор содержит два метода:

- **E next()** — вернуть значение следующего элемента и сдвинуть итератор "вперед"
- **boolean hasNext()** — вернуть true, если пройдены еще не все элементы, и false в противном случае

### forEach
 — это разновидность цикла for, **метод интерфейса Iterable**. Выполняет заданное действие для каждого элемента Iterable до тех пор, пока все элементы не будут обработаны или действие не вызовет исключение. 

## Методы итератора
- Проверка существования следующего элемента it.hasNext()
- Получение следующего элемента it.next()
- Удаление текущего элемента из коллекции remove()
###  Способы обхода коллекций 
 ![[Обход коллекции java.png|400]]
 ![[forEach Коллекции.png|400]]
## Разница между итераторами с fail-fast и fail-safe поведением?
Короткий ответ: Fail-fast итератор генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, а fail-safe – нет.

Подробнее: https://www.youtube.com/watch?v=PILSlTw4ZDc

Это не какие-то отдельные типы, а характеристики разных реализаций интерфейса Iterator. Они определяют, как поведет себя итератор при изменении перебираемой последовательности.

**Fail-fast – «БЫСТРЫЙ» итератор**. Когда после его создания коллекция как-либо изменилась (добавление, изменение, удаление элемента), он падает с ошибкой без лишних разбирательств.
Так работает итератор класса ArrayList, при изменении он выбрасывает **ConcurrentModificationException**. Рекомендуется не основывать логику программы на fail-fast отказах, и использовать их только как признак ошибки реализации.

**Fail-safe – «УМНЫЙ» итератор.** Итератор класса ConcurrentHashMap работает с копией данных, он не выбросит исключение при изменении коллекции, но может не увидеть часть свежих изменений.

Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count): 
- при изменении коллекции счетчик модификаций также изменяется; 
- при создании итератора ему передается текущее значение счетчика; 
- при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение.
![[failFast iteratot пример.png|350]]

![[failSafe Iterator пример.png|350]]
[Fail-Safe vs. Fail-Fast: Which Java Iterator Should You Choose? - YouTube](https://youtu.be/PILSlTw4ZDc)
## Отличие Enumeration и Iterator
Это два интерфейса в пакете **java.uti**l используются для обхода элементов коллекции. Хотя они выполняют одну и ту же функцию, между ними существуют некоторые различия.

>[!Note]+ Enumeration 
>— это устаревший интерфейс, используемый для обхода только устаревших классов, таких как Vector, HashTable и Stack.

Используя **Enumeration**, вы можете только перемещаться по коллекции, а с помощью **Итератора** можете также удалить элемент при обходе коллекции.

Методы – это основное различие между интерфейсами Enumeration и Iterator.
Можно сказать, что Iterator – это расширенная версия Enumeration.
![[Сравнение Enumeratoin и Iterator.png]]
**Итератор** является «быстрым» fail-fast итератором, то есть будет выброшено исключение ConcurrentModificationException, если коллекция изменится во время итерации с применением собственного метода remove(). Напротив, Enumeration не выбросит никаких исключений, даже если коллекция изменяется во время итерации.

Согласно Java API Docs, итератор всегда предпочтительнее перечисления:

### Как избежать ConcurrentModificationException во время перебора коллекции
- Попробовать подобрать другой итератор, работающий по принципу ==fail-safe==.
К примеру, для **List** можно использовать **ListIterator**. 
- Использовать **ConcurrentHashMap** и **CopyOnWriteArrayList** 
- Преобразовать список в массив и перебирать массив 
- Блокировать изменения списка на время перебора с помощью блока **synchronized** Отрицательная сторона последних двух вариантов – это ухудшение производительности

## Что будет если
### Обходя ArrayList, удалить элемент. Какое вылетит исключение?
Да, можно, но… единственный способ удалить элемент из коллекции при обходе, не получив при этом **ConcurrentModificationException** или
неопределенное поведение – удалить с помощью remove() того же инстанса итератора.
![[Пример удаления элемента ArrayList через Iteartor.png]]
### Удалить объект ArrayList через цикл for
![[Удаление элемента ArrayList через цикл for.png|300]]
Обычно формулируется в виде задачи на внимательность «что здесь не так»

Подвох в том, что итератор ArrayList, который используется в таком варианте цикла for, является fail-fast, то есть не поддерживает итерацию с параллельной модификацией. А параллельная модификация случается даже в одном потоке, что демонстрирует этот пример. Следующий шаг итератора после удаления элемента выбросит **ConcurrentModificationException**.

Не исключение, но неожиданный результат получится если пользоваться не итератором, а обычным циклом for – при каждом удалении нумерация элементов будет сдвигаться.

Единственный способ удалить элемент из коллекции при обходе, не получив при этом **ConcurrentModificationException** или неопределенное поведение – удалить с помощью remove() того же инстанса итератора. Вариант **ListIterator** поможет, если в теле цикла требуется и работа с индексами.

Некоторые коллекции (**CopyOnWriteArrayList** и **ConcurrentHashMap**), адаптированные под многопоточную среду и имеют fail-safe итераторы.

### Вызвать iterator.remove()
Если вызову iterator.remove() предшествовал вызов **iterator.next()**, то **iterator.remove()** удалит элемент коллекции, на который указывает итератор, в противном случае будет выброшено **IllegalStateException()**.

## Зачем нужен интерфейс Comparable и Comparator
### Интерфейс Comparable (сравнимый) 
содержит один единственный метод int compareTo(E item), который сравнивает текущий объект с объектом, переданным в качестве параметра.

Если этот метод возвращает отрицательное число, то текущий объект будет располагаться перед тем, который передается через параметр. Если метод вернет положительное число, то, наоборот, после второго объекта. Если метод возвратит ноль, значит, оба объекта равны.
>[!example]+
>![[Пример Comparable класса.png|400]]

###  Интерфейс Comparator 
Интерфейс Comparator содержит ряд методов, ключевым из которых является метод compare(), который возвращает числовое значение - если оно отрицательное, то объект a предшествует объекту b, иначе - наоборот. А если метод возвращает ноль, то объекты равны.

Для применения интерфейса нам сначала надо создать класс компаратора,
который реализует этот интерфейс.
>[!example]+
>![[Пример класса Comparator.png|400]]

## Разница
Comparable реализуется ВНУТРИ класса. По сути, определяет обычный/естественный порядок сравнения объектов. ОДИН метод compareTo(); 

Comparator - реализуется ВНЕ класса.
Можно реализовать разные варианты сортировки, основанные на сравнении различных полей (свойств объектов). Имеет РЯД методов, ключевой их них – compare();
