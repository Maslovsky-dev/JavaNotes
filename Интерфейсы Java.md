---
tags: Java/ООП
---
Интерфейсы определяют некоторый **функционал**, не имеющий конкретной **реализации**, который затем реализуют классы, применяющие эти интерфейсы. Один класс может применить множество интерфейсов.

**У интерфейса нет конструктора**

## Методы и переменные (константы)

**Интерфейс — набор абстрактных методов и статических
констант.**
- методы интерфейса являются public и abstract (публичными и абстрактными) - поля — public static final (константы)

Все методы интерфейса не имеют модификаторов доступа, но фактически по умолчанию доступ public, так как цель интерфейса - **определение функционала для реализации его классом**. Поэтому весь функционал должен быть открыт для реализации.

1. [[Абстрактные классы#Абстрактные методы]] в интерфейсах выглядят следующим образом
```java
public interface MyInterface {
    void myMethod();
}
```

2. [[Методы Java#Дефолт методы]]
3. Статические методы
Статические методы в интерфейсе являются методами класса и могут быть вызваны без создания экземпляра класса или его реализующего интерфейса. Они объявляются с ключевым словом `static`. Пример:
```java
public interface MyInterface {
    static void myStaticMethod() {
        // Реализация статического метода
    }
}
```

>[!NOTE] Статические методы в интерфейсах обеспечивают безопасность, не позволяя классам, которые реализуют интерфейс переопределять их.

1. Приватные методы (Java 9)
Приватные методы были введены в Java 9. Они могут быть использованы только внутри интерфейса для поддержки реализации других методов в этом интерфейсе. Они объявляются с ключевым словом `private`. Пример:
```java
public interface MyInterface {
    default void myMethod() {
        // Вызов приватного метода
        helperMethod();
    }

    private void helperMethod() {
        // Реализация приватного метода
    }
}

```
Кроме методов в интерфейсах могут быть определены статические константы. Хотя такие константы также не имеют модификаторов, но по умолчанию они имеют модификатор доступа public static final, и поэтому их значение доступно из любого места программы.

### Implements
Чтобы класс применил интерфейс, надо использовать ключевое слово **implements**:
```java
public class Program{
      
    public static void main(String[] args) {
             
        Book b1 = new Book("Java. Complete Referense.", "H. Shildt");
        b1.print();
    }
}
interface Printable{
 
    void print();
}
class Book implements Printable{
  
    String name;
    String author;
  
    Book(String name, String author){
          
        this.name = name;
        this.author = author;
    }
      
    public void print() {
      
        System.out.printf("%s (%s) \n", name, author);
    }
}
```

В данном случае класс **Book** реализует интерфейс **Printable**. При этом надо учитывать, что если класс применяет интерфейс, то он **должен реализовать все методы интерфейса**, как в случае выше реализован метод print. Потом в методе main мы можем создать объект класса **Book** и вызвать его метод **print**. Если класс не реализует какие-то методы интерфейса, то такой класс должен быть определен как абстрактный, а его неабстрактные классы-наследники затем должны будут реализовать эти методы.

**Нельзя напрямую создавать объекты интерфейсов**

Одним из преимуществ использования интерфейсов является то, что они позволяют добавить в приложение гибкости. Например, в дополнение к классу **Book** определим еще один класс, который будет реализовывать интерфейс **Printable**:

```java
class Journal implements Printable {
 
    private String name;
  
    String getName(){
        return name;
    }
  
    Journal(String name){
          
        this.name = name;
    }
    public void print() {
        System.out.println(name);
    }  
}
```

Класс **Book** и класс **Journal** связаны тем, что они реализуют интерфейс **Printable**. Поэтому мы динамически в программе можем создавать объекты **Printable** как экземпляры обоих классов:
```java
public class Program{
      
    public static void main(String[] args) {
             
        Printable printable = new Book("Java. Complete Reference", "H. Shildt");
        printable.print();      //  Java. Complete Reference (H. Shildt)
        printable = new Journal("Foreign Policy");
        printable.print();      // Foreign Policy
    }
}
interface Printable{
 
    void print();
}
class Book implements Printable{
  
    String name;
    String author;
  
    Book(String name, String author){
          
        this.name = name;
        this.author = author;
    }
      
    public void print() {
      
        System.out.printf("%s (%s) \n", name, author);
    }
}
class Journal implements Printable {
 
    private String name;
  
    String getName(){
        return name;
    }
  
    Journal(String name){
          
        this.name = name;
    }
    public void print() {
        System.out.println(name);
    }  
}
```

## Особенности
Поля могут быть только public static final

Интерфейс служит для объявления контракта объекта по отношению к внешнему миру

Внутри интерфейса может исполняться код
1. Статические методы
2. [[Методы Java#Дефолт методы|Дефолт методы]]
## Пример
[Класс String потребляющий в 2 раза меньше памяти](https://platform.kata.academy/user/courses/1/3/5/6)

## Множественное наследование
Интерфейс может наследоваться от нескольких интерфейсов

### Может ли интерфейс наследоваться от другого?
![[Наследование интерфейсов.png]]
![[Множественная реализация интерфейса.png]]
### Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?
Класс, наследующий конфликтующие интерфейсы, должен явно через **super** определить, какой именно метод вызвать:` InterfaceB.super.method();`
## Интерфейсы маркеры

Интерфейсы маркеры – это интерфейсы, у которых не определены ни методы, ни переменные. Реализация этих интерфейсов придает классу определенные свойства.

Например, интерфейсы Cloneable и Serializable, отвечающие за клонирование и сохранение объекта в информационном потоке, являются интерфейсами маркерами. Если класс реализует интерфейс Cloneable, это говорит о том, что объекты этого класса могут быть клонированы.

javaВложенные интерфейсы
![[Вложенные интерфейсы.png]]
И также как и в случае с классами, интерфейсы могут использоваться в качестве типа параметров метода или в качестве возвращаемого типа.



[[Сравнение абстрактного класса и интерфейса]]
