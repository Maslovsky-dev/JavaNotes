---
tags: Паттерны
---
Декоратор — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в **полезные «обёртки».**
![[Паттерн декоратор Img.png]]
**Проблема**

Вы работаете над библиотекой оповещений, которую можно подключать к разным программам, чтобы получать уведомления о важных событиях.
![[Пример применения для паттерна Декоратор.png]]
>[!example]+
Основой библиотеки является класс Notifier с методом send, который принимает на вход строку-сообщение и высылает её всем администраторам по электронной почте. Сторонняя программа должна создать и настроить этот объект, указав кому отправлять оповещения, а затем использовать его каждый раз, когда что-то случается.
>
В какой-то момент стало понятно, что одних email оповещений пользователям мало. Некоторые из них хотели бы получать извещения о критических проблемах через SMS. Другие хотели бы получать их в виде сообщений Facebook. Корпоративные пользователи хотели бы видеть сообщения в Slack.
>
Сначала вы добавили каждый из этих типов оповещений в программу, унаследовав их от базового класса Notifier. Теперь пользователь выбирал один из типов оповещений, который и использовался в дальнейшем.
>
Но затем кто-то резонно спросил, почему нельзя выбрать несколько типов оповещений сразу? Ведь если вдруг в вашем доме начался пожар, вы бы хотели получить оповещения по всем каналам, не так ли?
>
Вы попытались реализовать все возможные комбинации подклассов оповещений.
>
После того как вы добавили первый десяток классов, стало ясно, что такой подход **невероятно раздувает код программы.**

![[Паттерн декоратор комбинирование функционала наследованием.png]]

Нужен другой способ комбинирования поведения объектов, который не приводит к взрыву количества подклассов.

**Решение**

Наследование — это первое, что приходит в голову многим программистам, когда нужно расширить какое-то существующее поведение. Но механизм наследования имеет несколько досадных проблем.

- **Он статичен.** Вы не можете изменить поведение существующего объекта. Для этого вам надо создать новый объект, выбрав другой подкласс.
- Он **не разрешает наследовать поведение нескольких классов одновременно.** Из-за этого приходится создавать множество подклассов-комбинаций для получения совмещённого поведения.

Одним из способов обойти эти проблемы является замена наследования *агрегацией либо композицией*. Это когда один объект содержит ссылку на другой и **делегирует ему работу,** вместо того чтобы самому наследовать его поведение.

- **_Композиция_** **—** это более строгий вариант агрегации, при котором компоненты не могут жить без контейнера.

Как раз на этом принципе построен паттерн Декоратор. **Декоратор имеет альтернативное название — обёртка.** Оно более точно описывает суть паттерна: вы помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу.

В примере с оповещениями оставим в базовом классе простую отправку по электронной почте, а расширенные способы отправки сделаем декораторами.
![[Паттерн декоратор оповещения.png]]

Сторонняя программа, выступающая клиентом, во время первичной настройки будет заворачивать объект оповещений в те обёртки, которые соответствуют желаемому способу оповещения.

Последняя обёртка в списке и будет тем объектом, с которым клиент будет работать в остальное время. Для остального клиентского кода, по сути, ничего не изменится, ведь **все обёртки имеют точно такой же интерфейс,** что и базовый класс оповещений.

Таким же образом можно изменять не только способ доставки оповещений, но и форматирование, список адресатов и так далее. К тому же клиент может «до-обернуть» объект любыми другими обёртками, когда ему захочется.

Любая одежда — это аналог Декоратора. Применяя Декоратор, **вы не меняете первоначальный класс и не создаёте дочерних классов.**

Так и с одеждой — надевая свитер, вы не перестаёте быть собой, но **получаете новое свойство** — защиту от холода.

Вы можете пойти дальше и **надеть сверху ещё один декоратор —** плащ, чтобы защититься и от дождя.

Структур и псевдокод тут → https://refactoring.guru/ru/design-patterns/decorator

## **Когда применять**?

1. Когда вам нужно добавлять обязанности объектам на лету, незаметно для кода,
 который их использует.
	Объекты помещают в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс, поэтому клиентам без разницы, с чем работать — с обычным объектом данных или с обёрнутым.

2. Когда нельзя расширить обязанности объекта с помощью наследования.
	Во многих языках программирования есть ключевое слово final, которое может заблокировать наследование класса. Расширить такие классы можно только с помощью Декоратора.

## **Шаги реализации**

- Убедитесь, что в вашей задаче есть один основной компонент и несколько опциональных дополнений или надстроек над ним.
- Создайте интерфейс компонента, который описывал бы общие методы как для основного компонента, так и для его дополнений.
- Создайте класс конкретного компонента и поместите в него основную бизнес-логику.
- Создайте базовый класс декораторов. Он должен иметь поле для хранения ссылки на вложенный объект-компонент. Все методы базового декоратора должны делегировать действие вложенному объекту.
- И конкретный компонент, и базовый декоратор должны следовать одному и тому же интерфейсу компонента.
- Теперь создайте классы конкретных декораторов, наследуя их от базового декоратора. Конкретный декоратор должен выполнять свою добавочную функцию, а затем (или перед этим) вызывать эту же операцию обёрнутого объекта.
- Клиент берёт на себя ответственность за конфигурацию и порядок обёртывания объектов.


## ![[Преимущества и недостатки паттерна Декоратор.png]]

## Пример реализации
Предположим, у нас есть интерфейс `Coffee`, который представляет базовый функционал для кофе:

```java
// Интерфейс Coffee
interface Coffee {
    double getCost();
    String getDescription();
}
```

Теперь создадим конкретную реализацию этого интерфейса:

```java
// Конкретная реализация базового кофе
class SimpleCoffee implements Coffee {
    public double getCost() {
        return 2.0;
    }

    public String getDescription() {
        return "Simple coffee";
    }
}
```

Теперь предположим, что мы хотим добавить дополнительные опции для кофе, такие как молоко и шоколад. Вместо создания большого количества подклассов с каждой комбинацией опций, мы можем использовать шаблон Декоратор:

```java
// Базовый класс для декораторов
abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;

    public CoffeeDecorator(Coffee coffee) {
        this.decoratedCoffee = coffee;
    }

    public double getCost() {
        return decoratedCoffee.getCost();
    }

    public String getDescription() {
        return decoratedCoffee.getDescription();
    }
}

// Декоратор для молока
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }

    public double getCost() {
        return super.getCost() + 0.5;
    }

    public String getDescription() {
        return super.getDescription() + ", milk";
    }
}

// Декоратор для шоколада
class ChocolateDecorator extends CoffeeDecorator {
    public ChocolateDecorator(Coffee coffee) {
        super(coffee);
    }

    public double getCost() {
        return super.getCost() + 1.0;
    }

    public String getDescription() {
        return super.getDescription() + ", chocolate";
    }
}

```

Теперь мы можем использовать декораторы для расширения функциональности базового кофе:

```java
public class Client {
    public static void main(String[] args) {
        Coffee coffee = new SimpleCoffee();
        System.out.println("Cost: " + coffee.getCost() + ", Description: " + coffee.getDescription());

        // Добавляем молоко к кофе
        Coffee milkCoffee = new MilkDecorator(coffee);
        System.out.println("Cost: " + milkCoffee.getCost() + ", Description: " + milkCoffee.getDescription());

        // Добавляем молоко и шоколад к кофе
        Coffee milkAndChocoCoffee = new ChocolateDecorator(milkCoffee);
        System.out.println("Cost: " + milkAndChocoCoffee.getCost() + ", Description: " + milkAndChocoCoffee.getDescription());
    }
}
```

В данном примере мы создаем базовый класс `CoffeeDecorator`, который реализует интерфейс `Coffee` и хранит ссылку на оборачиваемый объект (также реализующий `Coffee`). Затем мы создаем два конкретных декоратора `MilkDecorator` и `ChocolateDecorator`, которые добавляют функциональность молока и шоколада к базовому кофе. Обратите внимание, что каждый декоратор вызывает методы базового кофе и добавляет свою собственную функциональность.

В результате мы можем создавать различные комбинации опций для кофе, динамически оборачивая базовый кофе в различные декораторы и получая разнообразные варианты кофе с различными характеристиками.
