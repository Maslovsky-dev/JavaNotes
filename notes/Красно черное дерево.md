---
tags: Алгоритмы/Деревья
---
[Симуляция красно-черного дерева](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html)
## Отличие бинарного дерева от красно-черного
1. Основное свойство:
    - Бинарное дерево: Каждый узел имеет не более двух потомков (левый и правый).
    - Красно-черное дерево: Это бинарное дерево, которое дополнительно обладает свойствами красной и черной **окраски узлов, обеспечивая балансировку.**

2. Сбалансированность:
    - Бинарное дерево: Может быть сбалансированным или несбалансированным, что зависит от порядка вставки элементов.
    - Красно-черное дерево: Гарантированно сбалансировано благодаря своим свойствам красной и черной окраски узлов. Эти свойства гарантируют, что длина самого длинного пути до листьев не превышает вдвое длину самого короткого пути.

3. Сложность операций:
    - Бинарное дерево: Операции поиска, вставки и удаления могут иметь сложность до **O(n)** в худшем случае, если дерево несбалансировано.
    - Красно-черное дерево: Операции поиска, вставки и удаления гарантированно имеют сложность **O(log n)** в худшем случае благодаря сбалансированности дерева.

4. Свойства красно-черных деревьев: Красно-черные деревья имеют следующие свойства:
    - Каждый узел либо красный, либо черный.
    - Корень и листья (NIL) дерева - черные узлы.
    - Если узел красный, то оба его потомка - черные узлы.
    - Все пути от узла до его листьев должны содержать одинаковое количество черных узлов (это называется "черной высотой").

5. Применение:
    - Бинарные деревья: Используются в различных структурах данных, таких как двоичные кучи, двоичные поисковые деревья и т.д.
    - Красно-черные деревья: Широко применяются в структурах данных и алгоритмах, требующих эффективной балансировки, например, в реализации ассоциативных массивов и словарей, а также в базах данных и системах файлов.


## Что такое красно-черное дерево?

Красно-черное дерево — это самобалансирующееся бинарное дерево поиска, то есть бинарное дерево поиска, которое автоматически поддерживает некоторый баланс.

Каждому узлу назначается цвет (красный или черный). Набор правил определяет, как должны располагаться эти цвета (например, у красного узла не может быть красных дочерних узлов). Такое расположение гарантирует, что дерево поддерживает определенный баланс.

После вставки и удаления узлов применяются достаточно сложные алгоритмы для проверки соблюдения правил — и, в случае отклонений, для восстановления заданных свойств путем перекрашивания узлов и поворотов.

### NIL-узлы в красно-черных деревьях

В литературе красно-черные деревья изображаются с так называемыми NIL-узлами и без них. Узел NIL — это лист, который не содержит значения. Узлы NIL становятся важными для алгоритмов позже, например, для определения цветов дяди или одноуровневых узлов.

В Java узлы NIL могут быть представлены просто `null`ссылками; подробнее об этом позже.

### Пример красно-черного дерева

В следующем примере показаны два возможных представления красно-черного дерева. На первом изображении показано дерево без (т. е. с неявными) NIL-листами; второе изображение показывает дерево с явными NIL-листами.

![[Красно черное дерево-1.png|350]]

Красно-черное дерево с неявными NIL-листами

![[Красно черное дерево-2.png|350]]

Красно-черное дерево с явными NIL-листами

### Свойства красно-черного дерева

Следующие правила обеспечивают баланс красно-черного дерева:

1. Каждый узел либо красный, либо черный.
2. (Корень черный.)
3. Все листья NIL черные.
4. Красный узел не должен иметь красных потомков.
5. Все пути от узла к листьям ниже содержат одинаковое количество черных узлов.

Правило 2 заключено в скобки, потому что оно не влияет на баланс дерева. Если потомок красного корня тоже красный, то этот корень должен быть окрашен в черный цвет в соответствии с правилом 4. Однако, если красный корень имеет только черных потомков, окрашивание корня в черный цвет не дает никаких преимуществ.

Поэтому правило 2 часто опускается в литературе.

При объяснении операций вставки и удаления и в коде Java я укажу, где были бы различия, если бы мы также реализовали правило 2

Кстати, из правил 4 и 5 следует, что красный узел всегда имеет либо два NIL-листа, либо два черных дочерних узла со значениями. Если бы у него был один NIL-лист и один черный дочерний элемент со значением, то в путях через этот дочерний элемент было бы как минимум на один черный узел больше, чем в пути к NIL-листу, что нарушило бы правило 5.

### Высота красно-черного дерева

Мы называем высоту красно-черного дерева максимальным количеством узлов от корня до NIL-листа, не включая корень. Высота красно-черного дерева в приведенном выше примере равна 4:

![[Красно черное дерево-3.png|350]]

Высота красно-черного дерева

Из правил 3 и 4 следует:

Самый _длинный_ путь от корня до листа (не считая корня) не более чем в два раза длиннее кратчайшего _пути_ от корня до листа.


>[!example]
>Предположим, что кратчайший путь имеет (помимо корня) _n_ черных узлов и не имеет красных узлов. Затем мы могли бы добавить еще _n_ красных узлов перед каждым черным узлом, не нарушая правило 3 (которое мы могли бы переформулировать так: никакие два красных узла не могут следовать друг за другом).
>
В следующем примере показан кратчайший путь через красно-черное дерево высоты четыре слева и самый длинный путь справа:
>
![[Красно черное дерево-4.png|350]]
>
Самый короткий и самый длинный путь в красно-черном дереве

Пути к NIL-листам слева имеют длину (исключая корень) 2. Пути к NIL-листам справа внизу имеют длину 4.
### Черная высота красно-черного дерева

Высота черного — это количество черных узлов от данного узла до его листьев. Черные NIL-листья учитываются, начальный узел — нет.

Черная высота всего дерева — это количество черных узлов от корня (это не считается) до NIL-листьев.

Черная высота всех показанных красно-черных деревьев равна 2.

## Java-реализация красно-черного дерева

В качестве отправной точки для реализации красно-черного дерева на Java я использую [исходный код Java для двоичного дерева поиска](https://www.happycoders.eu/algorithms/binary-search-tree-java/#Binary_Search_Tree_in_Java) из второй части серии статей о двоичном дереве.

Узлы представлены классом `[Node](https://github.com/SvenWoltmann/binary-tree/blob/main/src/main/java/eu/happycoders/binarytree/Node.java)` . Для простоты мы используем `int`примитивы в качестве значения узла.

Для реализации красно-черного дерева, помимо дочерних узлов `left`и `right`, нам нужна ссылка на родительский узел и цвет узла. Мы сохраняем цвет в a `boolean`, определяя красный как `false` и черный как `true`.

```java
public class Node { 
	int data; 
	Node left; 
	Node right; 
	Node parent; 
	boolean color; 
	public Node(int data) { 
		this.data = data; 
	} 
}
```

Реализуем красно-черное дерево в [RedBlackTree](https://github.com/SvenWoltmann/binary-tree/blob/main/src/main/java/eu/happycoders/binarytree/RedBlackTree.java)классе. Этот класс расширяет [BaseBinaryTree](https://github.com/SvenWoltmann/binary-tree/blob/main/src/main/java/eu/happycoders/binarytree/BaseBinaryTree.java)класс, представленный во второй части серии (который, по сути, предоставляет функцию `getRoot()`).

Мы добавим операции (вставка, поиск, удаление) в следующих разделах, шаг за шагом.

Но сначала мы должны определить некоторые вспомогательные функции.

## Вращение красного черного дерева

[Вставка](https://www.happycoders.eu/algorithms/binary-search-tree-java/#Binary_Search_Tree_Insertion) и [удаление](https://www.happycoders.eu/algorithms/binary-search-tree-java/#Binary_Search_Tree_Deletion) работают в основном так, как описано в статье о бинарных деревьях поиска.

После вставки и удаления пересматриваются красно-черные правила ( [см. выше ).](https://www.happycoders.eu/algorithms/red-black-tree-java/#Red-Black_Tree_Properties) Если они были нарушены, их необходимо восстановить. Это происходит путем перекрашивания узлов и поворотов.

Вращение работает точно так же, как с [деревьями AVL](https://www.happycoders.eu/algorithms/avl-tree-java/) , которые я описал в предыдущем уроке. Я покажу вам соответствующие диаграммы снова здесь. Вы можете найти подробные пояснения в разделе [«Вращение дерева AVL»](https://www.happycoders.eu/algorithms/avl-tree-java/#AVL_Tree_Rotation) только что упомянутой статьи.

### Правое вращение

На следующем рисунке показано правое вращение. Цвета не имеют никакого отношения к цветам красно-черного дерева. Они используются только для лучшего отслеживания движений узла.

Левый узел _L_ становится новым корнем; корень _N_ становится его правым потомком. Правый дочерний элемент _LR левого узла_ _L_ перед вращением становится левым дочерним элементом правого узла _N_ после вращения. Два белых узла _LL_ и _R_ не меняют своего относительного положения.

![[Красно черное дерево-5.png|450]]

Правое вращение в красно-черном дереве

Код Java немного длиннее, чем в дереве AVL — по следующим двум причинам:

1. Также нам нужно обновить `parent` ссылки узлов (в дереве AVL мы работали без `parent`ссылок).
2. Нам нужно обновить ссылки на родительский узел перед вращением и обратно (_N_ на рисунке). Для дерева AVL мы сделали это косвенно, вернув новый корень повернутого поддерева и «подключив» поворот к рекурсивному вызову операций вставки и удаления.

Вы можете найти реализацию правильного поворота в [исходном коде, начиная со строки 358](https://github.com/SvenWoltmann/binary-tree/blob/main/src/main/java/eu/happycoders/binarytree/RedBlackTree.java#L358)
```java
private void rotateRight(Node node) {
  Node parent = node.parent;
  Node leftChild = node.left;

  node.left = leftChild.right;
  if (leftChild.right != null) {
    leftChild.right.parent = node;
  }

  leftChild.right = node;
  node.parent = leftChild;

  replaceParentsChild(parent, node, leftChild);
}
```

Метод `replaceParentsChild()`, вызываемый в конце, устанавливает отношение родитель-потомок между родительским узлом бывшего корневого узла N _повернутого_ поддерева и его новым корневым узлом _L._ Вы можете найти его [в коде, начиная со строки 388](https://github.com/SvenWoltmann/binary-tree/blob/main/src/main/java/eu/happycoders/binarytree/RedBlackTree.java#L388):

```java
private void replaceParentsChild(Node parent, Node oldChild, Node newChild) {
  if (parent == null) {
    root = newChild;
  } else if (parent.left == oldChild) {
    parent.left = newChild;
  } else if (parent.right == oldChild) {
    parent.right = newChild;
  } else {
    throw new IllegalStateException("Node is not a child of its parent");
  }

  if (newChild != null) {
    newChild.parent = parent;
  }
}
```

### Левое вращение

Левое вращение работает аналогично: правый узел _R_ перемещается вверх. Корень _N_ становится левым потомком _R_ . Левый дочерний элемент _RL_ бывшего правого узла _R становится правым дочерним элементом левого узла_ _N_ после поворота . _L_ и _RR_ не меняют своего относительного положения.


![[Красно черное дерево-6.png|350]]

Левое вращение в красно-черном дереве

Вот код Java для левого поворота ([исходный код, начиная со строки 373](https://github.com/SvenWoltmann/binary-tree/blob/main/src/main/java/eu/happycoders/binarytree/RedBlackTree.java#L373)):

```java
private void rotateLeft(Node node) {
  Node parent = node.parent;
  Node rightChild = node.right;

  node.right = rightChild.left;
  if (rightChild.left != null) {
    rightChild.left.parent = node;
  }

  rightChild.left = node;
  node.parent = rightChild;

  replaceParentsChild(parent, node, rightChild);
}
```

## Операции с Красно-Черным деревом

Как и любое бинарное дерево, красно-черное дерево предоставляет операции поиска, вставки и удаления узлов. Мы рассмотрим эти операции шаг за шагом в следующих разделах.

### Поиск красно-черного дерева

Поиск работает как в любом двоичном дереве поиска: сначала мы сравниваем ключ поиска с корнем. Если ключ поиска меньше, продолжаем поиск в левом поддереве; если ключ поиска больше, продолжаем поиск в правом поддереве.

Мы повторяем это до тех пор, пока либо не найдем искомый узел, либо пока не достигнем NIL-листа (в коде Java: ссылки `null`). Достижение нулевого листа будет означать, что ключ, который мы ищем, не существует в дереве.

Графическое представление поиска смотрите в примере в [статье про бинарные деревья поиска](https://www.happycoders.eu/algorithms/binary-search-tree-java/#Binary_Search_Tree_Example).

Для красно-черного дерева реализуем итерационный вариант поиска. Вы можете найти его в [исходном коде, начиная со строки 14](https://github.com/SvenWoltmann/binary-tree/blob/main/src/main/java/eu/happycoders/binarytree/RedBlackTree.java#L14) :

```java
// Ищем позицию вставки от корня вниз и присоединяем новый узел к листу или полулисту.  
while (node != null) {  
    parent = node;  
    if (key < node.data) {  
        node = node.left;  
    } else if (key > node.data) {  
        node = node.right;  
    } else {  
        throw new IllegalArgumentException("BST already contains a node with key " + key); 
    }  
}
```

Этот код должен говорить сам за себя.

В [разделе «Поиск»](https://www.happycoders.eu/algorithms/binary-search-tree-java/#Searching) упомянутой выше статьи вы также можете найти рекурсивный вариант поиска.

### Вставка красно-черного дерева

Чтобы вставить новый узел, мы сначала действуем, как описано в разделе [«Вставка бинарного дерева поиска»](https://www.happycoders.eu/algorithms/binary-search-tree-java/#Binary_Search_Tree_Insertion) соответствующей статьи. Т.е. ищем позицию вставки от корня вниз и присоединяем новый узел к листу или полулисту.

Вы можете найти код в [`RedBlackTree`классе, начиная со строки 29](https://github.com/SvenWoltmann/binary-tree/blob/main/src/main/java/eu/happycoders/binarytree/RedBlackTree.java#L29) :

```java
public void insertNode(int key) {
    Node node = root;
    Node parent = null;

    // Traverse the tree to the left or right depending on the key
    while (node != null) {
        parent = node;
        if (key < node.data) {
            node = node.left;
        } else if (key > node.data) {
            node = node.right;
        } else {
            throw new IllegalArgumentException("BST already contains a node with key " + key);
        }
    }

    // Insert new node
    Node newNode = new Node(key);
    newNode.color = RED;

    if (parent == null) {
        root = newNode;
    } else if (key < parent.data) {
        parent.left = newNode;
    } else {
        parent.right = newNode;
    }

    newNode.parent = parent;
    fixRedBlackPropertiesAfterInsert(newNode);
}
```


Сначала мы окрашиваем новый узел в красный цвет, чтобы выполнялось правило 5, т. е. все пути имели одинаковое количество черных узлов после вставки.

Однако, если родительский узел вставленного узла также красный, мы нарушили правило 4. Затем нам нужно восстановить дерево, перекрасив его и/или повернув так, чтобы снова выполнялись все правила. Это делается в `fixRedBlackPropertiesAfterInsert()`методе, который вызывается в последней строке метода `insertNode()`.

Во время ремонта нам приходится иметь дело с пятью разными случаями:

- Случай 1: новый узел является корнем
- Случай 2: родительский узел красный, а корень
- Случай 3: родительские и дядюшки красные
- Случай 4: родительский узел красный, дядя-узел черный, вставленный узел является «внутренним внуком».
- Случай 5: родительский узел красный, дядя-узел черный, вставленный узел — «внешний внук».
