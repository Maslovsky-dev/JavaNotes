---
tags: Java/ПодКапотом
---
![[Структура JDK.png]]
## JDK
**JDK** (Java Development Kit) – включает **JRE** (минимальная реализация **JVM**) и набор инструментов разработчика приложений на языке Java:
- компилятор **JAVAC** или Just In Time компилятор
- стандартные библиотеки классов **Java** (library)
- примеры
- документация
- различные утилиты (программы для выполнения
специализированных типовых задач, связанных с работой оборудования и операционной системы (ОС)).
## JRE
JRE (Java Runtime Environment) – это минимально-необходимая реализация виртуальной машины для исполнения Java-приложений.
Состоит из JVM, ClassLoader и Library (стандартного набора библиотек и классов Java).
## JVM
JVM (Java Virtual Machine) – виртуальная машина Java исполняет байт-код Java, предварительно созданный из кода JIT компилятором, с помощью встроенного интерпретатора байткода. HotSpot представляет собой реализацию концепции JVM.
## Byte code
Байт-код Java — набор инструкций, скомпилированный компилятором, исполняемый JVM.

 ## Class loader
 [[Class loader]]

## JAVAC и JIT
**javac**:
`javac` - это компилятор Java, который используется для преобразования исходного кода на языке Java в байт-код (JVM). Когда вы пишете код на Java, вы создаете исходный код в файле с расширением `.java`. Затем вы используете `javac` для компиляции этого исходного кода в байт-код, который хранится в файлах с расширением `.class`. Эти файлы `.class` затем интерпретируются или компилируются Just-In-Time (JIT) компилятором в машинный код, который выполняется на конкретной платформе.

**JIT компилятор**:
JIT компилятор - это компонент виртуальной машины Java (JVM), который выполняет динамическую компиляцию байт-кода Java в **машинный код** во время выполнения программы. Когда Java-программа запускается, она сначала интерпретируется виртуальной машиной JVM. Однако для повышения производительности, чтобы уменьшить время выполнения программы, JIT компилятор может проанализировать участки кода, которые часто вызываются, и преобразовать их в машинный код. Этот процесс называется "Just-In-Time" компиляцией, потому что компиляция происходит непосредственно перед выполнением кода.
	**Когда начинает работать JIT компилятор?**
	На практике методы не компилируются при первом вызове. Для каждого метода виртуальная машина Java поддерживает счетчик вызовов, который увеличивается каждый раз при вызове метода. JVM интерпретирует метод, пока его счетчик вызовов не превысит **порог компиляции Just-In-Time**. Поэтому часто используемые методы [[Компилируемые и интерпретируемые языки|компилируются]] вскоре после запуска виртуальной машины Java, а менее используемые методы скомпилируются намного позже или вообще не выполняются. Порог компиляции Just-In-Time помогает быстрому запуску JVM и по-прежнему имеет улучшенную производительность. Порог был тщательно выбран для обеспечения оптимального баланса между временем запуска и долгосрочной эксплуатацией

>[!info]
>Таким образом, `javac` используется для статической компиляции исходного кода Java в байт-код, а JIT компилятор выполняет динамическую компиляцию байт-кода в машинный код во время выполнения программы на виртуальной машине Java.

## Раннее и позднее связывание
**1. Раннее связывание (статическое):** Раннее связывание означает, что связь между вызываемым методом (или переменной) и соответствующим кодом (который будет выполнен при вызове данного метода) устанавливается на этапе компиляции, до выполнения программы. Это происходит, когда тип объекта известен на этапе компиляции. Примеры раннего связывания в Java:

- Перегрузка методов: Когда в классе определены несколько методов с одинаковым именем, но разными параметрами (типами и/или количеством), компилятор определяет, какой метод вызывать на основе типов аргументов, переданных при вызове метода. Это решение принимается на этапе компиляции и остается неизменным во время выполнения.

- Использование статических полей и методов: Статические поля и методы принадлежат классу, а не конкретному объекту. Связь между статическим методом и его вызовом устанавливается на этапе компиляции.


**2. Позднее связывание (динамическое):** Позднее связывание означает, что связь между вызываемым методом (или переменной) и соответствующим кодом (который будет выполнен при вызове данного метода) устанавливается во время выполнения программы. Это происходит, когда тип объекта не известен на этапе компиляции и определяется только во время выполнения. Примеры позднего связывания в Java:

- Переопределение методов: Когда у наследующего класса есть метод с тем же именем и сигнатурой (типами параметров), что и у родительского класса, происходит переопределение метода. При вызове метода на объекте потомка будет вызван метод потомка, а не метод родителя. Это решение принимается во время выполнения, и JVM определяет, какой метод вызывать на основе реального типа объекта.

Таким образом, раннее связывание применяется в случаях, когда тип объекта известен на этапе компиляции, и выбор метода происходит на этом этапе. Позднее связывание используется, когда тип объекта определяется только во время выполнения, и выбор метода происходит динамически, исходя из типа реального объекта.

Оба этих типа связывания имеют свои применения в программировании на Java и играют важную роль в реализации полиморфизма и организации иерархий классов.

Пример позднего связывания

```java
class Animal {
    void makeSound() {
        System.out.println("Some generic animal sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Woof woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog();
        myAnimal.makeSound(); // Здесь происходит позднее связывание
    }
}
```

[[Garbage collector]]

[[Стек и куча в Java]]
