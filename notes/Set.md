---
tags: Java/Коллекции
---
Множество - обеспечивает уникальность содержащихся в ней элементов.

В основе Set лежит Map, у которого:
- ключи – это элементы множества Set
- значения – это константа-заглушка


При попытке создать дубликат метод **add** вернет false. Set содержит те же методы, что и интерфейсе Collection.
Определен метод **equals** сравнивающий множества по содержимому

Реализации SortedSet дают линейный порядок множества.
Элементы **упорядочены по возрастанию**.
Порядок либо натуральный (элементы реализуют интерфейс *Comparable*), либо его определяет **переданный в конструктор** *Comparator*.
![[Сравнение реализаций Set.png]]

![[Интерфейсы и реализации Set.png|200]]
## Sortedset Interfase
Обход итератором в порядке возрастания элементов. Порядок либо натуральный (элементы реализуют интерфейс *Comparable*), либо его определяет **переданный в конструктор** *Comparator*.

### TreeSet Impl
В основе TreeSet лежит TreeMap, у которого:
- ключи – это элементы TreeSet
- значения – это константа-заглушка (одна на всех)

HashSet не может гарантировать, что данные будут отсортированы, так как работает по другому алгоритму. Если сортировка для вас важна, то используйте TreeSet.

Реализует сбалансированное бинарное дерево поиска ([[Бинарное дерево]])

>[!tip] Что будет если добавлять элементы в TreeSet по возрастанию?
>В основе TreeSet лежит красно-черное дерево, которое умеет само себя балансировать.
В итоге, TreeSet все равно в каком порядке вы добавляете в него элементы, преимущества этой структуры данных будут сохраняться.

### NavigableSet Interface

>[!tip]+ интерфейс NavigableSet расширяет SortedSet
>Для итерации по порядку, получения ближайшего снизу, сверху, большего и меньшего заданному элемента.
Дополнительные операции:
>- headSet - возвращает подмножество объектов, меньших, чем заданный (живое множество, которое изменяется вместе с основным)
> - Min Max элемент

NavigableSet добавляет к привычному iterator (который идёт от меньшего к большему) итератор для обратного порядка — **descendingIterator**.

Кроме того, NavigableSet позволяет при помощи метода **descendingSet** получить вид на себя (View), в котором элементы идут в обратном порядке (через полученный элемент можно изменять элементы изначального **Set**).

Интересно, что NavigableSet, подобно Queue, умеет получать и убирать элементы из набора: pollFirst (минимальный) и pollLast (максимальный).
## HashSet Impl
В основе HashSet лежит HashMap, у которого:
- ключи – это элементы HashSet
- значения – это константа-заглушка

HashSet хранит элементы таким образом, чтобы элемент можно было очень быстро найти. Метод **contains()** у HashSet ищет элемент быстро, так как под капотом HashMap: элементы находятся в так называемых корзинах/бакетах/entry, которые выбираются исходя из значений самих элементов
![[Пример HashSet бакетов.png]]
>[!Warning] У Set нет метода get()
>Для получения элементов из Set используется Iterator

Несколько важных пунктов о HashSet:
- Класс реализует интерфейс Set, он может хранить только уникальные значения - Может хранить NULL – значения
- Порядок добавления элементов вычисляется с помощью хэш-кода
- HashSet также реализует интерфейсы Serializable и Cloneable
Для поддержания постоянного времени выполнения операций важно не устанавливать слишком высокую начальную ёмкость (или слишком низкий коэффициент загрузки).

## LinkedHashSet Impl

Класс LinkedHashSet расширяет класс HashSet, не добавляя никаких новых методов.
Класс поддерживает связный список элементов множества в том порядке, в котором они вставлялись. Это позволяет организовать упорядоченную итерацию вставки в набор.

## EnumSet AK
EnumSet — это одна из разновидностей реализации интерфейса Set для использования с перечислениями (Enum). EnumSet использует массив битов для хранения значений **(bit vector**), что позволяет получить высокую компактность и эффективность.

В структуре данных хранятся объекты только одного типа Enum, который указывается при создании экземпляра EnumSet. Все основные операции выполняются за константное время O(1) и в основном несколько быстрее (хотя и не гарантированно), чем их аналоги в реализации HashSet.

Пакетные операции (bulk operations, например, containsAll() и retainAll()) выполняются очень быстро, если их аргументом является экземпляр типа Enum.

Помимо этого, класс EnumSet предоставляет множество статических методов инициализации для упрощенного и удобного создания экземпляров.

Итерация по EnumSet осуществляется согласно порядку объявления элементов перечисления.

## Сравнение реализаций
### TreeSet и HashSet?
Класс HashSet реализует интерфейс Set, основан на хэш-таблице (оптимизирован для быстрого поиска). Не запоминает порядок добавления элементов. Может хранить null.
Класс TreeSet реализует интерфейс SortedSet реализован на основе красно-чёрного дерева (хранит элементы в отсортированном по возрастанию порядке).
### LinkedHashSet и HashSet?
LinkedHashSet отличается от HashSet только тем, что в его основе лежит LinkedHashMap вместо HashMap.

Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов (insertion-order, то есть хранит элементы в порядке добавления).
При добавлении элемента, который уже присутствует в LinkedHashSet (т.е. с одинаковым ключом), порядок обхода элементов не изменяется.
