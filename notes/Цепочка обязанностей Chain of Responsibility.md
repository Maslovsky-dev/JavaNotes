---
tags: Паттерны
--- 
**Цепочка обязанностей** — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

![[Цепочка обязанностей (Chain of Responsibility)-1.png]]

##  Проблема

Представьте, что вы делаете систему приёма онлайн-заказов. Вы хотите ограничить к ней доступ так, чтобы только авторизованные пользователи могли создавать заказы. Кроме того, определённые пользователи, владеющие правами администратора, должны иметь полный доступ к заказам.

Вы быстро сообразили, что эти проверки нужно выполнять последовательно. Ведь пользователя можно попытаться «залогинить» в систему, если его запрос содержит логин и пароль. Но если такая попытка не удалась, то проверять расширенные права доступа попросту не имеет смысла.

![[Цепочка обязанностей (Chain of Responsibility)-2.png]]

Запрос проходит ряд проверок перед доступом в систему заказов.

На протяжении следующих нескольких месяцев вам пришлось добавить ещё несколько таких последовательных проверок.

- Кто-то резонно заметил, что неплохо бы проверять данные, передаваемые в запросе перед тем, как вносить их в систему — вдруг запрос содержит данные о покупке несуществующих продуктов.
- Кто-то предложил блокировать массовые отправки формы с одним и тем же логином, чтобы предотвратить подбор паролей ботами.
- Кто-то заметил, что форму заказа неплохо бы доставать из кеша, если она уже была однажды показана.

![[Цепочка обязанностей (Chain of Responsibility)-3.png]]

Со временем код проверок становится всё более запутанным.

С каждой новой «фичей» код проверок, выглядящий как большой клубок условных операторов, всё больше и больше раздувался. При изменении одного правила приходилось трогать код всех проверок. А для того, чтобы применить проверки к другим ресурсам, пришлось продублировать их код в других классах.

Поддерживать такой код стало не только очень хлопотно, но и затратно. И вот в один прекрасный день вы получаете задачу рефакторинга...

##  Решение

Как и многие другие поведенческие паттерны, Цепочка обязанностей базируется на том, чтобы превратить отдельные поведения в объекты. В нашем случае каждая проверка переедет в отдельный класс с единственным методом выполнения. Данные запроса, над которым происходит проверка, будут передаваться в метод как аргументы.

А теперь по-настоящему важный этап. Паттерн предлагает связать объекты обработчиков в одну цепь. Каждый из них будет иметь ссылку на следующий обработчик в цепи. Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке.

Передавая запросы в первый обработчик цепочки, вы можете быть уверены, что все объекты в цепи смогут его обработать. При этом длина цепочки не имеет никакого значения.

И последний штрих. Обработчик не обязательно должен передавать запрос дальше, причём эта особенность может быть использована по-разному.

В примере с фильтрацией доступа обработчики прерывают дальнейшие проверки, если текущая проверка не прошла. Ведь нет смысла тратить попусту ресурсы, если и так понятно, что с запросом что-то не так.

![[Цепочка обязанностей (Chain of Responsibility)-4.png]]

Обработчики следуют в цепочке один за другим.

Но есть и другой подход, при котором обработчики прерывают цепь только когда они _могут_ обработать запрос. В этом случае запрос движется по цепи, пока не найдётся обработчик, который может его обработать. Очень часто такой подход используется для передачи событий, создаваемых классами графического интерфейса в результате взаимодействия с пользователем.

Например, когда пользователь кликает по кнопке, программа выстраивает цепочку из объекта этой кнопки, всех её родительских элементов и общего окна приложения на конце. Событие клика передаётся по этой цепи до тех пор, пока не найдётся объект, способный его обработать. Этот пример примечателен ещё и тем, что цепочку всегда можно выделить из древовидной структуры объектов, в которую обычно и свёрнуты элементы пользовательского интерфейса.

![[Цепочка обязанностей (Chain of Responsibility)-5.png]]

Цепочку можно выделить даже из дерева объектов.

Очень важно, чтобы все объекты цепочки имели общий интерфейс. Обычно каждому конкретному обработчику достаточно знать только то, что следующий объект в цепи имеет метод `выполнить`. Благодаря этому, связи между объектами цепочки будут более гибкими. Кроме того, вы сможете формировать цепочки на лету из разнообразных объектов, не привязываясь к конкретным классам.

##  Аналогия из жизни

![[Цепочка обязанностей (Chain of Responsibility)-6.png]]

Пример общения с поддержкой.

Вы купили новую видеокарту. Она автоматически определилась и заработала под Windows, но в вашей любимой Ubuntu «завести» её не удалось. Со слабой надеждой вы звоните в службу поддержки.

Первым вы слышите голос автоответчика, предлагающий выбор из десятка стандартных решений. Ни один из вариантов не подходит, и робот соединяет вас с живым оператором.

Увы, но рядовой оператор поддержки умеет общаться только заученными фразами и давать шаблонные ответы. После очередного предложения «выключить и включить компьютер» вы просите связать вас с настоящими инженерами.

Оператор перебрасывает звонок дежурному инженеру, изнывающему от скуки в своей каморке. Уж он-то знает, как вам помочь! Инженер рассказывает вам, где скачать подходящие драйвера и как настроить их под Ubuntu. Запрос удовлетворён. Вы кладёте трубку.

##  Структура

![[Цепочка обязанностей (Chain of Responsibility)-7.png|350]]

1. **Обработчик** определяет общий для всех конкретных обработчиков интерфейс. Обычно достаточно описать единственный метод обработки запросов, но иногда здесь может быть объявлен и метод выставления следующего обработчика.
    
2. **Базовый обработчик** — опциональный класс, который позволяет избавиться от дублирования одного и того же кода во всех конкретных обработчиках.
    
    Обычно этот класс имеет поле для хранения ссылки на следующий обработчик в цепочке. Клиент связывает обработчики в цепь, подавая ссылку на следующий обработчик через конструктор или сеттер поля. Также здесь можно реализовать базовый метод обработки, который бы просто перенаправлял запрос следующему обработчику, проверив его наличие.
    
3. **Конкретные обработчики** содержат код обработки запросов. При получении запроса каждый обработчик решает, может ли он обработать запрос, а также стоит ли передать его следующему объекту.
    
    В большинстве случаев обработчики могут работать сами по себе и быть неизменяемыми, получив все нужные детали через параметры конструктора.
    
4. **Клиент** может либо сформировать цепочку обработчиков единожды, либо перестраивать её динамически, в зависимости от логики программы. Клиент может отправлять запросы любому из объектов цепочки, не обязательно первому из них.

##  Когда применять?

- Когда программа должна обрабатывать **разнообразные запросы несколькими способами**, но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся.

 С помощью Цепочки обязанностей вы можете связать потенциальных обработчиков в одну цепь и при получении запроса поочерёдно спрашивать каждого из них, не хочет ли он обработать запрос.

- Когда важно, чтобы **обработчики выполнялись один за другим в строгом порядке**.

 Цепочка обязанностей позволяет запускать обработчиков последовательно один за другим в том порядке, в котором они находятся в цепочке.

- Когда набор объектов, способных обработать запрос, должен задаваться динамически.

 В любой момент вы можете вмешаться в существующую цепочку и переназначить связи так, чтобы убрать или добавить новое звено.

##  Шаги реализации

1. Создайте **интерфейс обработчика** и опишите в нём основной метод обработки.
    
    Продумайте, в каком виде клиент должен передавать данные запроса в обработчик. Самый гибкий способ — превратить данные запроса в объект и передавать его целиком через параметры метода обработчика.
    
2. Имеет смысл создать **абстрактный базовый класс обработчиков**, чтобы не дублировать реализацию метода получения следующего обработчика во всех конкретных обработчиках.
    
    Добавьте в базовый обработчик поле для хранения ссылки на следующий объект цепочки. Устанавливайте начальное значение этого поля через конструктор. Это сделает объекты обработчиков неизменяемыми. Но если программа предполагает динамическую перестройку цепочек, можете добавить и сеттер для поля.
    
    Реализуйте базовый метод обработки так, чтобы он перенаправлял запрос следующему объекту, проверив его наличие. Это позволит полностью скрыть поле-ссылку от подклассов, дав им возможность передавать запросы дальше по цепи, обращаясь к родительской реализации метода.
    
3. Один за другим создайте **классы конкретных обработчиков** и реализуйте в них методы обработки запросов. При получении запроса каждый обработчик должен решить:
    
    - Может ли он обработать запрос или нет?
    - Следует ли передать запрос следующему обработчику или нет?
4. Клиент может собирать цепочку обработчиков самостоятельно, опираясь на свою бизнес-логику, либо получать уже готовые цепочки извне. В последнем случае цепочки собираются фабричными объектами, опираясь на конфигурацию приложения или параметры окружения.

5. Клиент может посылать запросы любому обработчику в цепи, а не только первому. Запрос будет передаваться по цепочке до тех пор, пока какой-то обработчик не откажется передавать его дальше, либо когда будет достигнут конец цепи.

6. Клиент должен знать о динамической природе цепочки и быть готов к таким случаям:
    
    - Цепочка может состоять из единственного объекта.
    - Запросы могут не достигать конца цепи.
    - Запросы могут достигать конца, оставаясь необработанными.
## Преимущества и недостатки паттерна цепочка обязанностей


![[Преимущества и недостатки паттерна Цепочка обязанностей-1.png]]
## Пример реализации
Сначала создадим класс для представления запроса о помощи:
```java
public class HelpRequest {
    private String requestType;
    private String description;

    public HelpRequest(String requestType, String description) {
        this.requestType = requestType;
        this.description = description;
    }

    public String getRequestType() {
        return requestType;
    }

    public String getDescription() {
        return description;
    }
}
```

Затем создадим абстрактный класс, который будет представлять обработчик запроса:
```java
public abstract class HelpHandler {
    protected HelpHandler successor;
	//Назначить преемника (следующий обработчик)
    public void setSuccessor(HelpHandler successor) {
        this.successor = successor;
    }
	//Обработать запрос
    public abstract void handleRequest(HelpRequest helpRequest);
}

```

Теперь создадим несколько конкретных обработчиков:
```java
public class SoftwareHelpHandler extends HelpHandler {
    @Override
    public void handleRequest(HelpRequest helpRequest) {
        if (helpRequest.getRequestType().equals("Software")) {
            System.out.println("Software Help: " + helpRequest.getDescription());
        } else if (successor != null) {
            successor.handleRequest(helpRequest);
        }
    }
}

public class HardwareHelpHandler extends HelpHandler {
    @Override
    public void handleRequest(HelpRequest helpRequest) {
        if (helpRequest.getRequestType().equals("Hardware")) {
            System.out.println("Hardware Help: " + helpRequest.getDescription());
        } else if (successor != null) {
            successor.handleRequest(helpRequest);
        }
    }
}

public class GeneralHelpHandler extends HelpHandler {
    @Override
    public void handleRequest(HelpRequest helpRequest) {
        System.out.println("General Help: " + helpRequest.getDescription());
    }
}

```

Теперь можно использовать эти классы для создания цепочки обработчиков и передавать запрос по цепочке:
```java
public class ChainOfResponsibilityExample {
    public static void main(String[] args) {
	    //Экземпляры конкретных обработчиков
        HelpHandler softwareHandler = new SoftwareHelpHandler();
        HelpHandler hardwareHandler = new HardwareHelpHandler();
        HelpHandler generalHandler = new GeneralHelpHandler();
		//Настраиваем цепочку путем назначения преемника каждому обработчику
        softwareHandler.setSuccessor(hardwareHandler);
        hardwareHandler.setSuccessor(generalHandler);
		//Создаем список различных запросов
        HelpRequest softwareRequest = new HelpRequest("Software", "How to install a software?");
        HelpRequest hardwareRequest = new HelpRequest("Hardware", "The printer is not working.");
        HelpRequest networkRequest = new HelpRequest("Network", "Unable to connect to the internet.");
		//Пропускаем все запросы через первые обработчик
        softwareHandler.handleRequest(softwareRequest);
        softwareHandler.handleRequest(hardwareRequest);
        softwareHandler.handleRequest(networkRequest);
    }
}

```

Вывод программы:
```java
Software Help: How to install a software?
Hardware Help: The printer is not working.
General Help: Unable to connect to the internet.
```
Таким образом, запросы обрабатываются по цепочке обязанностей до тех пор, пока один из обработчиков не обработает запрос или пока цепочка не достигнет конечного обработчика.
