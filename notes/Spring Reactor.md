---
tags: Spring/Reactor 
---
Давайте обобщим, что может возвращать функция:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/de6/76a/b7a/de676ab7a31d44236ab8d2497ca6e290.png)

- Single/Synchronous;

Обычная функция возвращает одно значение, и делает это синхронно. 

- Multipple/Synchronous;

Если мы используем Java 8, можем возвращать из функции поток данных Stream. Когда вернулось много значений, их можно отправлять на обработку. Но мы не можем отправить на обработку данные до того, как все они получены — ведь Stream работают только синхронно.

- Single/Asynchronous;

Здесь уже используется асинхронный подход, но функция возвращает только одно значение:

- либо CompletableFuture (Java), и через какое-то время приходит асинхронный ответ;
- либо Mono, возвращающая  одно значение в библиотеке Spring Reactor.
- Multiple/Asynchronous.

А вот тут как раз — реактивные потоки. Они асинхронные, то есть возвращают значение не сразу, а через какое-то время. И именно в этом варианте можно получить поток значений, причем эти значения будут растянуты во времени  Таким образом, мы комбинируем преимущества потоков Stream, позволяющих вернуть цепочку значений, и асинхронности, позволяющей отложить возврат значения.

Например, вы читаете файл, а он меняется. В случае Single/Asynchronous вы через какое-то время получаете целиком весь файл. В случае Multiple/Asynchronous вы получаете поток данных из файла, который сразу же можно начинать обрабатывать. То есть можно одновременно читать данные, обрабатывать их, и, возможно, куда-то записывать. . Реактивные асинхронные потоки называются:

- Publisher (в спецификации Java 9);
- Observable (в RxJava);
-  Flux (в Spring Reactor).
## Netty as a non-blocking server

Рассмотрим пример использования реактивных потоков Flux вместе со Spring Reactor. В основе Reactor лежит сервер Netty. Spring Reactor — это основа технологии, которую мы будем использовать. А сама технология называется WebFlux. Чтобы WebFlux работал, нужен асинхронный неблокирующий сервер.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/e2a/6a4/efa/e2a6a4efad280c35c16b717164e22bf7.png)

Схема работы сервера Netty похожа на то, как работает Node.js. Есть Selector — входной поток, который принимает запросы от клиентов и отправляет их на выполнение в освободившиеся потоки. Если в качестве синхронного сервера (Servlet-контейнера) используется **Tomcat**, то в качестве асинхронного используется **Netty**.

Давайте посмотрим, сколько вычислительных ресурсов расходуют Netty и Tomcat на выполнение одного запроса:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/ec5/4ed/d37/ec54edd37275cb57b869708bfcb4e5ac.png)

Throughput — это общее количество обработанных данных. При небольшой нагрузке, до первых 300 пользователей у RxNetty и Tomcat оно одинаковое, а после Netty уходит в приличный отрыв — почти в 2 фраза.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/f3c/2dc/0c9/f3c2dc0c933c97fd9114d221944d6b6d.png)

## Blocking vs Reactive

У нас есть два стека обработки запросов:

- Традиционный блокирующий стек.
- Неблокирующий стек — в нем все происходит асинхронно и реактивно.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/172/42f/63b/17242f63ba4aa79884e5ef3d6c554f9b.png)

В блокирующем стеке все строится на Servlet API, в реактивном неблокирующем стеке — на Netty. 

Сравним реактивный стек и стек Servlet. 

В Reactive Stack применяется технология Spring WebFlux. Например, вместо Servlet API используются реактивные стримы.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/ac1/627/d59/ac1627d59fb7111af7014ccd9cb8efbe.png)

Чтобы мы получили ощутимое преимущество в производительности, весь стек должен быть реактивным. Поэтому чтение данных тоже должно происходить из реактивного источника. 

Например, если у нас используется стандартный JDBC, он является не реактивным блокирующим источником, потому что JDBC не поддерживает неблокирующий ввод/вывод. Когда мы отправляем запрос в базу данных, приходится ждать, пока результат этого запроса придет. Соответственно, получить преимущество не удается. 

В Reactive Stack мы получаем преимущество за счет реактивности. Netty работает с пользователем, Reactive Streams Adapters — со Spring WebFlux, а в конце находится **реактивная база**: то есть весь стек получается реактивным. Давайте посмотрим на него на схеме:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/eba/505/f57/eba505f57b0a85f7c994898e0d3803b7.png)
Data Repo — репозиторий, где хранятся данные. В случае, если есть запросы, допустим, от клиента или внешнего сервера, они через Flux поступают в контроллер, обрабатываются, добавляются в репозиторий, а потом ответ идет в обратную сторону.

При этом все это делается неблокирующим способом: мы можем использовать либо Push-подход, когда мы определяем, что делать при каждой следующей операции, либо Pull-подход, если есть вероятность Backpressure, и мы хотим сами контролировать скорость обработки данных, а не получать все данные разом.

## Операторы

В реактивных потоках огромное количество операторов. Многие из них похожи на те, которые есть в обычных стримах Java. Мы рассмотрим только несколько самых распространенных операторов, которые понадобятся нам для практического примера применения реактивности. 

#### Filter operator

Скорее всего, вы уже знакомы с фильтрами из интерфейса Stream. 

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/10f/8ca/d39/10f8cad39f3c879ec204a7acb903aadc.png)

По синтаксису этот фильтр точно такой же, как обычный. Но если в стриме Java 8 все данные есть сразу, здесь они могут появляться постепенно. Стрелки вправо — это временная шкала, а в кружочках находятся появляющиеся данные. Мы видим, что фильтр оставляет в итоговом потоке только значения, превышающие 10.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/650/c37/9ad/650c379ad6269b4eb544ba74699c21d5.png)

Take 2 означает, что нужно взять только первые два значения.

#### Map operator

Оператор Map тоже хорошо знаком:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/9f5/c94/576/9f5c94576ee7fc2ceee2b9b30c0cd55b.png)

Это действие, происходящее с каждым значением. Здесь — умножить на десять: было 3, стало 30; было 2, стало 20 и т.д.

#### Delay operator

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/f77/e90/ab6/f77e90ab67db5b549aa67050fe802e9a.png)

Задержка: все операции сдвигаются. Этот оператор может понадобиться, когда значения уже генерируются, но подготовительные процессы еще происходят, поэтому приходится отложить обработку данных из потока.

#### Reduce operator

Еще один всем известный оператор:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/e27/211/d80/e27211d8014b034fad0ee32df7b45eac.png)

Он дожидается конца работы потока (onComplete) — на схеме она представлена вертикальной чертой. После чего мы получаем результат — здесь это число 15. Оператор reduce сложил все значения, которые были в потоке.

#### Scan operator

Этот оператор отличается от предыдущего тем, что не дожидается конца работы потока.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/90f/2f4/b1d/90f2f4b1d5fa29a692cfa78c76a87870.png)

Оператор scan рассчитывает текущее значение нарастающим итогом: сначала был 1, потом прибавил к предыдущему значению 2, стало 3, потом прибавил 3, стало 6, еще 4, стало 10 и т.д. На выходе получили 15. Дальше мы видим вертикальную черту — onComplete. Но, может быть, его никогда не произойдет: некоторые потоки не завершаются. Например, у термометра или датчика дыма нет завершения, но scan поможет рассчитать текущее суммарное значение, а при некоторой комбинации операторов — текущее среднее значение всех данных в потоке.

#### Merge operator

Объединяет значения двух потоков.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/09e/4e8/b0d/09e4e8b0d8707e1a921aeb61b94d85fe.png)

Например, есть два температурных датчика в разных местах, а нам нужно обрабатывать их единообразно, в общем потоке .

#### Combine latest

Получив новое значение, комбинирует его с последним значением из предыдущего потока.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/675/efc/7c5/675efc7c5bf3e68580d9696ade0d73cb.png)

Если в потоке возникает новое событие, мы его комбинируем с последним полученным значением из другого потока. Скажем, таким образом мы можем комбинировать значения от датчика дыма и термометра: при появлении нового значения температуры в потоке temperatureStream оно будет комбинироваться с последним полученным значением задымленности из smokeStream. И мы будем получать пару значений. А уже по этой паре можно выполнить итоговый расчет:

temperatureStream.combineLatest(smokeStream).map((x, y) -> x > X && y > Y)

 В итоге на выходе у нас получается поток значений true или false — включить или выключить колокольчик. Он будет пересчитываться каждый раз, когда будет появляться новое значение в temperatureStream или в smokeStream.

**FlatMap operator**

Этот оператор вам, скорее всего, знаком по стримам Java 8. Элементами потока в данном случае являются другие потоки. Получается поток потоков. Работать с ними неудобно, и в этих случаях нам может понадобиться «уплостить» поток. 

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/e25/277/440/e252774405c831ec5ee28aa1e4212fe0.png)

Можно представить такой поток как конвейер, на который ставят коробки с запчастями. До того, как мы начнем их применять, запчасти нужно достать из коробок. Именно это делает оператор flatMap.

Flatmap часто используется при обработке потока данных, полученных с сервера. Т.к. сервер возвращает поток, чтобы мы смогли обрабатывать отдельные данные, этот поток сначала надо «развернуть». Это и делает flatMap.

**Buffer operator**

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/19f/4ba/fa1/19f4bafa13086cd7e196860b2f64477a.png)

Это оператор, который помогает группировать данные. На выходе Buffer получается поток, элементами которого являются списки (List в Java). Он может пригодиться, когда мы хотим отправлять данные не по одному, а порциями.  

Мы с самого начала говорили, что реактивные потоки позволяют разбить задачу на подзадачи, и обрабатывать их маленькими порциями. Но иногда лучше наоборот, собрать много маленьких частей в блоки. Скажем, продолжая пример с конвейером и запчастями, нам может понадобиться отправлять запчасти на другой завод (другой сервер). Но каждую отдельную запчасть отправлять неэффективно. Лучше их собрать в коробки, скажем по 100 штук, и отправлять более крупными партиями.

На схеме выше мы группируем отдельные значения по три элемента (так как всего их было пять, получилась «коробка» из трех, а потом из двух значений). То есть если flatMap распаковывает данные из коробок, buffer, наоборот, упаковывает их.

Всего существует более сотни операторов реактивного программирования. Здесь разобрана только небольшая часть.

## Итого

Есть два подхода:

- Spring MVC — традиционная модель, в которой используется JDBC, императивная логика и т.д.
- Spring WebFlux, в котором используется реактивный подход и сервер Netty.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/81b/8f3/cbc/81b8f3cbcc70789e74a728af3e1648d7.png)

Есть кое-что, что их объединяет. Tomcat, Jetty, Undertow могут работать и со Spring MVC, и со Spring WebFlux. Однако дефолтным сервером в Spring для работы с реактивным подходом является именно Netty.
