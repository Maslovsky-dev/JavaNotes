---
tags: Паттерны
---

Шаблон проектирования Фабричный метод (Factory Method) относится к классу порождающих шаблонов проектирования и используется для создания объектов без явного указания их конкретного класса. Вместо этого, он предоставляет абстрактный метод (фабричный метод), который подклассы могут реализовать для создания объектов определенного типа.
>[!note]+ Почему фабричный метод называется фабричным?
>Фабричный метод называется так из-за своей аналогии с фабрикой в реальном мире. Фабрика в промышленности - это место, где производятся различные продукты. (кострюли, сковородки, миски) Аналогично, в программировании, фабричный метод является механизмом создания объектов различных типов.
>
Шаблон проектирования Фабричный метод позволяет делегировать создание экземпляра объекта его подклассам. **Вместо того чтобы явно вызывать конструктор класса для создания объекта, клиентский код вызывает абстрактный фабричный метод, определенный в суперклассе.** Подклассы переопределяют этот метод и возвращают экземпляры своих собственных классов.
>
Таким образом, фабричный метод создает абстракцию над процессом создания объектов, позволяя клиентскому коду быть независимым от конкретных классов и типов создаваемых объектов. Он предоставляет механизм для создания объектов различных типов с использованием общего интерфейса.
>
>>Кроме шаблона проектирования Фабричный метод, существуют также другие шаблоны, связанные с концепцией фабрики, такие как Абстрактная фабрика (Abstract Factory) и Статическая фабрика (Static Factory). Все они способствуют достижению принципа инверсии зависимостей (Dependency Inversion Principle) и повышению гибкости и переносимости кода.

## **Проблема**

Представьте, что вы создаёте программу управления грузовыми перевозками. Сперва вы рассчитываете перевозить товары только на автомобилях. Поэтому весь ваш код работает с объектами класса Грузовик.

Большая часть существующего кода **жёстко привязана** к классам Грузовиков. Чтобы добавить в программу классы **морских Судов**, понадобится перелопатить всю программу. Более того, если вы потом решите добавить в программу ещё один вид транспорта, то всю эту работу придётся повторить.

В итоге вы получите ужасающий код, наполненный условными операторами, которые выполняют то или иное действие, в зависимости от класса транспорта.

## **Решение**

Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя
оператор new, а **через вызов особого фабричного метода.** Не пугайтесь, объекты всё
равно будут создаваться при помощи new, но делать это будет фабричный метод.

Чтобы эта система заработала, все возвращаемые **объекты должны иметь общий
интерфейс.** Подклассы смогут производить объекты различных классов, следующих
одному и тому же интерфейсу.

Например, классы Грузовик и Судно реализуют **интерфейс Транспорт с методом доставить.**
Каждый из этих классов реализует метод по-своему: грузовики везут грузы по земле, а суда — по морю.
Фабричный метод в классе `Дорожной Логистики` вернёт объект-грузовик, а класс `Морской Логистики` — объект-судно.
![[Паттерн Фабричный метод проблема.png]]

Структура и псевдокод по ссылке: https://refactoring.guru/ru/design-patterns/factory-method

## **Когда применять?**

1. Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.
	Фабричный метод отделяет код производства продуктов от остального кода, который эти продукты использует. Благодаря этому, код производства можно расширять, не трогая основной. Так, чтобы добавить поддержку нового продукта, вам нужно создать новый подкласс и определить в нём фабричный метод, возвращая оттуда экземпляр нового продукта.

2. Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.

	Пользователи могут расширять классы вашего фреймворка через наследование. Но как сделать так, чтобы фреймворк создавал объекты из этих новых классов, а не из стандартных?

	Решением будет дать пользователям возможность расширять не только желаемые компоненты, но и классы, которые создают эти компоненты. А для этого создающие классы должны иметь конкретные создающие методы, которые можно определить.

3. Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.

Такая проблема обычно возникает при работе с тяжёлыми ресурсоёмкими объектами,
такими, как подключение к базе данных, файловой системе и т. д.

Представьте, сколько действий нужно совершить, чтобы повторно использовать
существующие объекты:

- Сначала вам следует создать общее хранилище, чтобы хранить в нём все создаваемые объекты.
- При запросе нового объекта нужно будет заглянуть в хранилище и проверить, есть ли там неиспользуемый объект. А затем вернуть его клиентскому коду.
- Но если свободных объектов нет — создать новый, не забыв добавить его в хранилище. Весь этот код нужно куда-то поместить, чтобы не засорять клиентский код.

Самым удобным местом был бы конструктор объекта, ведь все эти проверки нужны
только при создании объектов. Но, увы, конструктор всегда создаёт новые объекты, он не
может вернуть существующий экземпляр.

Значит, нужен другой метод, который бы отдавал как существующие, так и новые
объекты. Им и станет фабричный метод.

## **Шаги реализации**

- Приведите все создаваемые продукты к **общему интерфейсу**
- В классе, который производит продукты, создайте пустой фабричный метод. В качестве возвращаемого типа укажите общий интерфейс продукта.
- Найдите **все участки кода класса, создающие продукты**. Поочерёдно замените эти
участки вызовами фабричного метода, перенося в него код создания различных продуктов.
- В фабричный метод, возможно, придётся добавить несколько параметров, контролирующих, какой из продуктов нужно создать.

На этом этапе фабричный метод, скорее всего, будет выглядеть удручающе. В нём будет жить большой условный оператор, выбирающий класс создаваемого продукта. Это можно исправить.

- Для каждого типа продуктов заведите подкласс и переопределите в нём фабричный метод. Переместите туда код создания соответствующего продукта из суперкласса.
- Если создаваемых продуктов слишком много для существующих подклассов создателя, вы можете подумать о введении параметров в фабричный метод, которые позволят возвращать различные продукты в пределах одного подкласса.

Например, у вас есть класс `Почта` с подклассами `АвиаПочта` и `НаземнаяПочта`, а также классы продуктов `Самолёт`, `Грузовик` и `Поезд`. `Авиа` соответствует `Самолётам`, но для `НаземнойПочты` есть сразу два продукта. Вы могли бы создать новый подкласс почты для поездов, но проблему можно решить и по-другому. Клиентский код может передавать в фабричный метод `НаземнойПочты` аргумент, контролирующий тип создаваемого продукта.

- Если после всех перемещений фабричный метод стал пустым, можете сделать его абстрактным. Если в нём что-то осталось — не беда, это будет его реализацией по умолчанию.
## ![[Преимущества и недостатки паттерна Фабричный метод.png]]

## Пример реализации

```java
// Интерфейс продукта
interface Product {
    void doSomething();
}

// Конкретный продукт
class ConcreteProductA implements Product {
    public void doSomething() {
        System.out.println("Product A is doing something.");
    }
}

// Конкретный продукт
class ConcreteProductB implements Product {
    public void doSomething() {
        System.out.println("Product B is doing something.");
    }
}

// Абстрактный класс Creator (создатель)
abstract class Creator {
    public void someOperation() {
        // Выполнение каких-то операций
        System.out.println("Some operation in Creator class.");

        // Фабричный метод для создания продукта
        Product product = createProduct();

        // Выполнение операций с продуктом
        product.doSomething();
    }

    // Абстрактный фабричный метод, который должны реализовать подклассы
    protected abstract Product createProduct();
}

// Конкретный создатель
class ConcreteCreatorA extends Creator {
    // Реализация фабричного метода для создания продукта типа A
    protected Product createProduct() {
        return new ConcreteProductA();
    }
}

// Конкретный создатель
class ConcreteCreatorB extends Creator {
    // Реализация фабричного метода для создания продукта типа B
    protected Product createProduct() {
        return new ConcreteProductB();
    }
}

// Клиентский код
public class Client {
    public static void main(String[] args) {
        Creator creatorA = new ConcreteCreatorA();
        Creator creatorB = new ConcreteCreatorB();

        creatorA.someOperation();
        creatorB.someOperation();
    }
}

```
