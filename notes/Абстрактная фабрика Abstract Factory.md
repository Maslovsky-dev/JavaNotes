---
tags: Паттерны
---
**Абстрактная фабрика** — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.
![[Абстрактная фабрика.png]]

##  Проблема

Представьте, что вы пишете симулятор мебельного магазина. Ваш код содержит:
1. Семейство зависимых продуктов. Скажем, `Кресло` + `Диван` + `Столик`.

2. Несколько вариаций этого семейства. Например, продукты `Кресло`, `Диван` и `Столик` представлены в трёх разных стилях: `Ар-деко`, `Викторианском` и `Модерне`.

![[Семейство объектов.png]]
Вам нужен такой способ создавать объекты продуктов, чтобы они сочетались с другими продуктами того же семейства. Это важно, так как клиенты расстраиваются, если получают несочетающуюся мебель.
![[Несочетающиеся объекты.png]]
Кроме того, вы не хотите вносить изменения в существующий код при добавлении новых продуктов или семейcтв в программу. Поставщики часто обновляют свои каталоги, и вы бы не хотели менять уже написанный код каждый раз при получении новых моделей мебели.

## Решение

Для начала паттерн Абстрактная фабрика предлагает выделить общие интерфейсы для отдельных продуктов, составляющих семейства. Так, все вариации кресел получат общий интерфейс `Кресло`, все диваны реализуют интерфейс `Диван` и так далее.
![[Реализация интерфейсов объектами.png]]
Далее вы создаёте _абстрактную фабрику_ — общий интерфейс, который содержит методы создания всех продуктов семейства (например, `создатьКресло`, `создатьДиван` и `создатьСтолик`). Эти операции должны возвращать **абстрактные** типы продуктов, представленные интерфейсами, которые мы выделили ранее — `Кресла`, `Диваны` и `Столики`.
![[Возврат абстрактных типов продуктов.png]]
Как насчёт вариаций продуктов? Для каждой вариации семейства продуктов мы должны создать свою собственную фабрику, реализовав абстрактный интерфейс. Фабрики создают продукты одной вариации. Например, `ФабрикаМодерн` будет возвращать только `КреслаМодерн`,`ДиваныМодерн` и `СтоликиМодерн`.

Клиентский код должен работать как с фабриками, так и с продуктами только через их общие интерфейсы. Это позволит подавать в ваши классы любой тип фабрики и производить любые продукты, ничего не ломая.

Осталось прояснить последний момент: **кто создаёт объекты конкретных фабрик,** если
клиентский код работает только с интерфейсами фабрик? Обычно программа создаёт конкретный объект фабрики **при запуске,** причём тип фабрики выбирается, исходя из параметров окружения или конфигурации.

## **Когда применять?**

1. Когда бизнес-логика программы должна работать с разными видами связанных друг с другом продуктов, не завися от конкретных классов продуктов.
	Абстрактная фабрика скрывает от клиентского кода подробности того, как и какие
	конкретно объекты будут созданы. Но при этом клиентский код может работать со всеми
	типами создаваемых продуктов, поскольку их общий интерфейс был заранее определён.

2. Когда в программе уже используется Фабричный метод, но очередные изменения предполагают введение новых типов продуктов.
	В хорошей программе каждый класс отвечает только за одну вещь. **Если класс имеет слишком много фабричных методов, они способны затуманить его основную функцию.** Поэтому имеет смысл вынести всю логику создания продуктов в отдельную иерархию классов, применив абстрактную фабрику.

## **Шаги реализации**

- Создайте таблицу соотношений типов продуктов к вариациям семейств продуктов.
- Сведите все вариации продуктов к общим интерфейсам.
- Определите интерфейс абстрактной фабрики. Он должен иметь фабричные методы для создания каждого из типов продуктов.
- Создайте классы конкретных фабрик, реализовав интерфейс абстрактной фабрики. Этих классов должно быть столько же, сколько и вариаций семейств продуктов.
- Измените код инициализации программы так, чтобы она создавала определённую фабрику и передавала её в клиентский код.
- Замените в клиентском коде участки создания продуктов через конструктор вызовами соответствующих методов фабрики. 
## ![[Преимущества и недостатки паттерна Абстрактная фабрика.png]]

## Пример реализации
Допустим, у нас есть иерархия продуктов, состоящая из двух семейств: Button (кнопка) и Checkbox (флажок).

```java
// Интерфейс для кнопки
interface Button {
    void render();
}

// Интерфейс для флажка (Checkbox)
interface Checkbox {
    void render();
}

// Конкретная реализация кнопки для операционной системы Windows
class WindowsButton implements Button {
    public void render() {
        System.out.println("Rendering a button in Windows style.");
    }
}

// Конкретная реализация флажка для операционной системы Windows
class WindowsCheckbox implements Checkbox {
    public void render() {
        System.out.println("Rendering a checkbox in Windows style.");
    }
}

// Конкретная реализация кнопки для операционной системы MacOS
class MacOSButton implements Button {
    public void render() {
        System.out.println("Rendering a button in MacOS style.");
    }
}

// Конкретная реализация флажка для операционной системы MacOS
class MacOSCheckbox implements Checkbox {
    public void render() {
        System.out.println("Rendering a checkbox in MacOS style.");
    }
}

// Абстрактная фабрика, которая определяет интерфейсы для создания кнопок и флажков
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// Конкретная реализация абстрактной фабрики для операционной системы Windows
class WindowsGUIFactory implements GUIFactory {
    public Button createButton() {
        return new WindowsButton();
    }

    public Checkbox createCheckbox() {
        return new WindowsCheckbox();
    }
}

// Конкретная реализация абстрактной фабрики для операционной системы MacOS
class MacOSGUIFactory implements GUIFactory {
    public Button createButton() {
        return new MacOSButton();
    }

    public Checkbox createCheckbox() {
        return new MacOSCheckbox();
    }
}

// Клиентский код
public class Client {
    public static void main(String[] args) {
        // Создаем фабрику для операционной системы Windows
        GUIFactory windowsFactory = new WindowsGUIFactory();
        // Создаем кнопку с помощью фабрики
        Button windowsButton = windowsFactory.createButton();
        // Создаем флажок с помощью фабрики
        Checkbox windowsCheckbox = windowsFactory.createCheckbox();
        
        // Рендерим кнопку и флажок
        windowsButton.render();
        windowsCheckbox.render();

        // Создаем фабрику для операционной системы MacOS
        GUIFactory macosFactory = new MacOSGUIFactory();
        // Создаем кнопку с помощью фабрики
        Button macosButton = macosFactory.createButton();
        // Создаем флажок с помощью фабрики
        Checkbox macosCheckbox = macosFactory.createCheckbox();

        // Рендерим кнопку и флажок
        macosButton.render();
        macosCheckbox.render();
    }
}
```
