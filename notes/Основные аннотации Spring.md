---
tags: Spring
---
## Аннотации
**@ComponentScan** - путь по которому Spring будет искать классы для создания бинов
	Обычно используется в конфигурационных бинах **@Configuration** или над Main классом
**@Component** - класс, который будет сконфигурирован как Bean
**@Bean** - указывает, что метод создает, настраивает и инициализирует новый объект, управляемый Spring IoC контейнером
**@Configuration** - указывает, что класс содержит методы определения бинов

## @Bean и @Component
Обе аннотации используются для внедрения зависимостей и управления жизненным циклом объектов, но имеют некоторые ключевые различия.

**@Bean:**

- `@Bean` является одним из способов определения бинов в Spring и применяется **к методам** в конфигурационных классах (классах, помеченных `@Configuration`).
- Когда метод помечен `@Bean`, он создает и возвращает экземпляр объекта, который будет управляем Spring контейнером. Этот метод может настраивать и возвращать бин с дополнительной конфигурацией (например, с использованием параметров, условий и т. д.).
- Метод с аннотацией `@Bean` может иметь имя (по умолчанию оно совпадает с именем метода), и это имя используется как идентификатор бина в контейнере. Вы также можете указать явное имя бина через атрибут `name` аннотации.
Пример:
```java
@Configuration
public class AppConfig {
    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
}
```

**@Component:**

- `@Component` является базовой аннотацией для определения бинов в Spring и применяется к классам.
- Когда класс помечен `@Component`, он становится кандидатом для создания бина в контейнере Spring. По умолчанию имя бина будет названием класса с маленькой буквы.
- `@Component` используется для обычных бинов без дополнительной конфигурации, в то время как `@Bean` обеспечивает больше гибкости при создании бинов.
Пример:
```java
@Component
public class MyComponent {
    // Код класса MyComponent
}
```

>[!NOTE]
>Выбор между `@Bean` и `@Component` зависит от того, какие возможности вам необходимы. Если вам нужна дополнительная настройка бина или логика при его создании, вы можете использовать `@Bean` в конфигурационных классах. Если же вам достаточно просто создать бин без дополнительных настроек, `@Component` может быть более простым и удобным вариантом.

## @Service и @Repository
**@Service и @Repository** являются частными случаями аннотации @Component.
Технически они одинаковы, но используются их для разных целей.

**@Service** указывает, что используем сервис-слой, отвечающий за бизнес-логику.

**@Repository** указывает на то, что класс предоставляет механизм для CRUD операций: для хранения, извлечения, поиска, обновления и удаления операций с объектами. Этот слой отвечает за доступ к данным.

Задача @Repository заключается также в том, чтобы отлавливать определенные исключения персистентности (Persistence Exception) и пробрасывать их как одно непроверяемое исключение Spring Framework. Для этого в контекст должен быть добавлен класс PersistenceExceptionTranslationPostProcessor.

## @Autowired и @Resource
Ключевые различия между `@Autowired` и `@Resource`:

- `@Autowired` является частью Spring Framework и более гибкий в использовании.
- `@Resource` является стандартной аннотацией Java EE и менее гибкий, но может быть полезен, если вам нужно внедрить зависимость по имени.
- `@Autowired` работает с Spring-специфичными типами внедрения (например, `@Qualifier`, `@Primary`), тогда как `@Resource` не поддерживает их.
- `@Autowired` требует наличия Spring контейнера, тогда как `@Resource` может быть использован как в Spring, так и в контейнерах Java EE.
## @Autowired
![[Применение аннотации @Autowired.png]]
За обработку @Autowired отвечает BeanPostProcessor

>[!NOTE]
>По умолчанию Spring распознает объекты для вставки по ТИПУ. Если в контейнере доступно более одного бина одного и того же типа, будет выброшено исключение.
>
>**Если нет подходящих бинов для внедрения**,
>Spring вызовет исключение `NoSuchBeanDefinitionException`. Если установить атрибут `required` в `false`, то внедрение будет необязательным, и если бин не будет найден, поле или аргумент будет оставлено неинициализированным (или `null`, если это поле)

Для избежание этого можно указать аннотацию Spring Framework **@Qualifier**("название поля"), где название fooFormatter — это имя (Id) одного из нескольких бинов одного типа, находящихся в контейнере и доступных для внедрения →![[Qualifier Autowired.png|300]]

![[Autowired по имени поля.png]]

## @Resource
- `@Resource` является стандартной аннотацией в Java EE и также поддерживается **Spring**. Она используется для внедрения зависимостей по имени.
- Она может быть применена только **к полям и методам с аргументами**. Когда контейнер Spring встречает `@Resource`, он ищет бин по имени (или имени указанному через атрибут `name`) и автоматически внедряет его в объект, помеченный этой аннотацией.
- По умолчанию, `@Resource` также пытается внедрить бин по типу, если бин не найден по имени.
- Атрибут `name` позволяет явно указать имя бина, который нужно внедрить.
Пример:
```java
@Component
public class MyClass {
    @Resource(name = "myDependency")
    private Dependency dependency;
    // ...
}
```

## @Inject
[Разница между @Inject и @Autowired в Spring Framework](https://sky.pro/media/raznicza-mezhdu-inject-i-autowired-v-spring-framework/)
@Inject также связывает бины по типу, но в случае, если несколько бинов имеют один и тот же тип, будет выброшено исключение. В отличие от @Autowired, если бин не найден, @Inject не приводит к ошибке при старте приложения, вместо этого значение будет null.

Пример использования @Inject:

``` java
@Inject
private` `CustomerService customerService;
```

## @Lookup
[Как использовать аннотацию @Lookup - SYSOUT](https://sysout.ru/kak-ispolzovat-annotatsiyu-lookup/)
Обычно бины в приложении Spring являтся синглтонами, и для внедрения зависимостей мы используем конструктор или сеттер.
Но бывает и другая ситуация: имеется бин _Car_ — синглтон (singleton bean), и ему требуется каждый раз новый экземпляр бина _Passenger_. То есть _Car_ – синглтон, а _Passenger_ – так называемый прототипный бин (prototype bean). Жизненные циклы бинов разные. Бин _Car_ создается контейнером только раз, а бин _Passenger_ создается каждый раз новый – допустим, это происходит каждый раз при вызове какого-то метода бина _Car_. **Вот здесь то и пригодится внедрение бина с помощью _Lookup_ метода**. Оно происходит не при инициализации контейнера, а позднее: каждый раз, когда вызывается метод.

## @Primary и Qualifier
Если есть несколько бинов, которые реализуют один интерфейс, то аннотации @Primary и @Qualifier указывают какой именно бин необходимо внедрить.
## @Primary
Аннотация _@Primary_ задает бин, который будет внедрен по умолчанию
```java
@Repository
@Primary
public class AnimalRepository1 implements IAnimalRepository { //Если существует AnimalRepository2
    @Override
    public void save() {
        System.out.println("AnimalRepository 1 save");
    }
}
```

## @Qualifier
Аннотация _@Qualifier_ позволяет уточнить **имя бина**, который надо внедрить. Используется прямо перед аргументом.

В этот раз давайте скажем Spring внедрить бин _AnimalRepository2._ Для этого укажем в аннотации _@Qualifier_ имя бина.

>[!INFO]
> Имя бина  такое же, как имя класса, но с маленькой буквы. При условии, что имя класса начинается только с одной большой буквы (наш случай).

```java
@Service
public class AnimalService {
    private IAnimalRepository animalRepository;

    @Autowired
    public AnimalService(@Qualifier("animalRepository2") IAnimalRepository animalRepository){
        this.animalRepository=animalRepository;
    }

    public void save(){
        animalRepository.save();
    }
}
```
## @Conditional и @Profile
[[Conditional и Profile]]

## ComponentScan
Сканирование происходит благодаря аннотации _@ComponentScan_. В Sping Boot приложении она явно не прописывается, но содержится внутри аннотации _@SpringBootApplication_, с помощью которой аннотирован главный класс приложения.

Если необходимо, чтобы Spring использовал только определенный набор классов компонентов, то нужно использовать аннотацию @ComponentScan. Эта аннотация указывает на конкретное расположение классов bean-компонентов, которые Spring должен будет проинициализировать.

Эту аннотацию можно использовать с параметрами или без них.

Без параметров Spring будет сканировать текущий пакет и его подпакеты, а при параметризации сообщит Spring, где именно искать пакеты.
![[Аннотация ComponentScan.png|400]]
Подробнее про отбор классов [Spring @ComponentScan - Filter Types | Baeldung](https://www.baeldung.com/spring-componentscan-filter-type)

## [[Transactional]]
