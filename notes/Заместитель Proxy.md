---
tags: Паттерны
--- 
**Заместитель** — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то _до_ или _после_ передачи вызова оригиналу.

![[Паттерн Заместитель.png]]
 **Проблема**

Для чего вообще контролировать доступ к объектам? Рассмотрим такой пример: у вас есть внешний ресурсоёмкий объект, который нужен не все время, а изредка.


![[Проблема, которую решает Заместитель.png]]
Мы могли бы создавать этот объект не в самом начале программы, а только тогда, когда он кому-то реально понадобится. Каждый клиент объекта получил бы некий код отложенной инициализации. Но, вероятно, это привело бы к множественному дублированию кода.
В идеале, этот код хотелось бы поместить прямо в служебный класс, но это не всегда возможно. Например, код класса может находиться в закрытой сторонней библиотеке.

 **Решение**

Паттерн Заместитель предлагает создать новый класс-дублёр, имеющий тот же интерфейс, что и оригинальный служебный объект. При получении запроса от клиента объект-заместитель **сам бы создавал экземпляр служебного объекта** и переадресовывал бы ему всю реальную работу.

![[Решение с помощью Заместителя.png]]

Заместитель «притворяется» базой данных, ускоряя работу за счёт ленивой инициализации и кеширования повторяющихся запросов.

Но в чём же здесь польза? Вы могли бы поместить в класс заместителя какую-то промежуточную логику, которая выполнялась бы до (или после) вызовов этих же методов в настоящем объекте. А благодаря одинаковому интерфейсу, объект-заместитель можно передать в любой код, ожидающий сервисный объект.

 **Аналогия из жизни**
![[Платёжная карта — это заместитель пачки наличных.png]]
Платёжной картой можно расплачиваться, как и наличными.

Платёжная карточка — это заместитель пачки наличных. И карточка, и наличные имеют общий интерфейс — ими можно оплачивать товары. Для покупателя польза в том, что не надо таскать с собой тонны наличных, а владелец магазина рад, что ему не нужно делать дорогостоящую инкассацию наличности в банк — деньги поступают к нему на счёт напрямую.

 **Структура**


![[Структура классов паттерна Заместитель.png]]


## Когда применять
1. Ленивая инициализация (виртуальный прокси). Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных.

Вместо того, чтобы грузить данные сразу после старта программы, можно сэкономить ресурсы и создать объект тогда, когда он действительно понадобится.

2. Защита доступа (защищающий прокси). Когда в программе есть разные типы пользователей, и вам хочется защищать объект от неавторизованного доступа. Например, если ваши объекты — это важная часть операционной системы, а пользователи — сторонние программы (хорошие или вредоносные).

Прокси может проверять доступ при каждом вызове и передавать выполнение служебному объекту, если доступ разрешён.

3. Локальный запуск сервиса (удалённый прокси). Когда настоящий сервисный объект находится на удалённом сервере.

В этом случае заместитель транслирует запросы клиента в вызовы по сети в протоколе, понятном удалённому сервису.

4. Логирование запросов (логирующий прокси). Когда требуется хранить историю обращений к сервисному объекту.

Заместитель может сохранять историю обращения клиента к сервисному объекту.

5, Кеширование объектов («умная» ссылка). Когда нужно кешировать результаты запросов клиентов и управлять их жизненным циклом.

Заместитель может подсчитывать количество ссылок на сервисный объект, которые были отданы клиенту и остаются активными. Когда все ссылки освобождаются, можно будет освободить и сам сервисный объект (например, закрыть подключение к базе данных).

Кроме того, Заместитель может отслеживать, не менял ли клиент сервисный объект. Это позволит использовать объекты повторно и здóрово экономить ресурсы, особенно если речь идёт о больших прожорливых сервисах.

## Шаги реализации
-   Определите интерфейс, который бы сделал заместитель и оригинальный объект взаимозаменяемыми.
    
-   Создайте класс заместителя. Он должен содержать ссылку на сервисный объект. Чаще всего, сервисный объект создаётся самим заместителем. В редких случаях заместитель получает готовый сервисный объект от клиента через конструктор.
    
-   Реализуйте методы заместителя в зависимости от его предназначения. В большинстве случаев, проделав какую-то полезную работу, методы заместителя должны передать запрос сервисному объекту.
    
-   Подумайте о введении фабрики, которая решала бы, какой из объектов создавать — заместитель или реальный сервисный объект. Но, с другой стороны, эта логика может быть помещена в создающий метод самого заместителя.
    
-   Подумайте, не реализовать ли вам ленивую инициализацию сервисного объекта при первом обращении клиента к методам заместителя.

## ![[Преимущества и недостатки паттерна Заместитель Proxy.png]]
## Пример реализации
Допустим, у нас есть интерфейс для сервиса загрузки изображений:

```java
// Интерфейс сервиса загрузки изображений
public interface ImageService {
    void displayImage();
}
```

Затем у нас есть реальная реализация этого сервиса:

```java
// Реальная реализация сервиса загрузки изображений
public class RealImageService implements ImageService {
    private String filename;

    public RealImageService(String filename) {
        this.filename = filename;
        loadImageFromDisk();
    }

    private void loadImageFromDisk() {
        System.out.println("Загрузка изображения " + filename + " с диска");
    }

    @Override
    public void displayImage() {
        System.out.println("Просмотр изображения " + filename);
    }
}
```

Теперь создадим прокси для этого сервиса:

```java
// Прокси для сервиса загрузки изображений
public class ImageProxy implements ImageService {
    private String filename;
    private RealImageService realImageService;

    public ImageProxy(String filename) {
        this.filename = filename;
    }

    @Override
    public void displayImage() {
        if (realImageService == null) {
            realImageService = new RealImageService(filename);
        }
        realImageService.displayImage();
    }
}
```

Теперь можно использовать прокси для загрузки и отображения изображений без прямого доступа к реальному сервису. Прокси будет загружать реальное изображение только тогда, когда оно реально нужно:

```java
public class Main {
    public static void main(String[] args) {
        ImageService imageService = new ImageProxy("image.jpg");

        // Изображение будет загружено только при вызове displayImage()
        imageService.displayImage();

        // Изображение не будет загружено повторно, так как у нас уже есть его копия
        imageService.displayImage();
    }
}
```

В результате, при запуске кода мы получим:

Загрузка изображения image.jpg с диска 
Просмотр изображения image.jpg 
Просмотр изображения image.jpg

Здесь `ImageProxy` выступает в роли прокси для `RealImageService`, и реальное изображение загружается с диска только при первом вызове `displayImage()`. Последующие вызовы будут использовать уже загруженное изображение из реальной реализации.

## В реальных проектах

**Когда использовать proxy**
![[Применение паттерна proxy.png]]
	[[Hibernate#PROXY|Hibernate Proxy]]
	[[Spring Proxy]]
