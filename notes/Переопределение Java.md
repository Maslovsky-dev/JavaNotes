---
tags: Java/ООП
---

**Переопределение метода** (@Override) позволяет взять какой-то метод родительского класса и написать в каждом классе-наследнике свою **специфическую реализацию** этого метода. Новая реализация «заменит» родительскую в дочернем классе.
## Условия для переопределения метода
1. Метод производного класса должен иметь в точности тот же **набор параметров**, что и метод базового класса.
2. Метод базового класса должен быть виден в производном классе.
3. **Тип**, возвращаемый методом производного класса, должен совпадать или быть подклассом типа, возвращаемого методом базового класса.
4. Метод производного класса должен иметь **модификатор доступа**, такой же или более открытый, чем метод базового класса.
Если условия выполнены, то метод класса наследника заменит собой одноименный метод родителя
- Можно изменить тип возвращаемого значения в меньшую сторону (подкласс), модификатор доступа в большую сторону

Аннотация `@Override` - явно декларирует намерение переопределить метод и поможет проверить правильность переопределения
[Hexlet - переопределение методов](https://ru.hexlet.io/courses/java_101/lessons/override_in_java/theory_unit#:~:text=%D0%9F%D0%B5%D1%80%D0%B5%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0%20(%D0%B0%D0%BD%D0%B3%D0%BB.,%D0%BE%D0%B4%D0%B8%D0%BD%20%D0%B8%D0%B7%20%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2%20%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8%20%D0%BF%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC%D0%B0.)

Создание экземпляра класса наследника всегда включает инициализацию базового класса, т.е. вызов его конструктора
Когда нужен вызов конструктора с параметрами, нужно прописать таковой в классе родителе. Иначе компилятор не поймет, какие параметры передавать
### Можно ли сузить уровень доступа/ тип возвращаемого значения при переопределении метода?
Модификаторы доступа сузить нельзя, можно только **расширить** (или оставить как есть)
Если типы возвращаемого значения совместимы, то сузить можно.
### Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы?
В сигнатуре метода ничего изменить нельзя. Можно только расширить уровень доступа
### Переопределение нативных методов
В java нельзя переопределить нативные методы, т.к. реализация нативных методов находится за пределами java

### Переопределение статических методов
[[static java#Может ли static метод быть перегружен или переопределен?|Переопределение статических методов]]

## Переопределение методов equals и hash code
**Equals**
![[Переопределение equals java.png|500]]
**HashCode**
![[Переопределение hashCode.png|600]]
### Что будет, если переопределить equals() не переопределяя hashCode()?
Нарушится контракт. Классы и методы, которые использовали правила этого контракта могут некорректно работать. Так для объекта HashMap это может привести к тому, что пара, которая была помещена в Map, возможно не будет найдена в ней при обращении к Map, если используется новый экземпляр ключа.
![[equals и hashСode вместе.png]]
[[Equals и hashCode]]
