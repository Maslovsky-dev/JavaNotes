---
tags: Java/Исключения
---
Нередко в процессе выполнения программы могут возникать ошибки, при том необязательно по вине разработчика. Некоторые из них трудно предусмотреть или предвидеть, а иногда и вовсе невозможно. Так, например, может неожиданно оборваться сетевое подключение при передаче файла. Подобные ситуации называются исключениями.

## Исключения
Это особый класс в языке Java, который нужен для того, чтобы отслеживать ошибки программы, передавать их пользователю или разработчику в читаемом виде и пытаться их обработать, без падения программы.

Когда возникает исключительное состояние, создается объект класса Exception. Этот объект пересылается в метод, обрабатывающий данный тип исключительной ситуации.
Исключения могут возбуждаться и для того, чтобы сообщить о некоторых нештатных ситуациях.
## Иерархия исключений
![[Иерархия исключений Java.png]]
- Error - ошибки виртуальной машины. Error можно поймать, но пытаться его обработать не нужною.
	Пример:
	java.lang.OutOfMemoryError - не хватило памяти
	java.lang.NoClassDefFoundError - виртуальная машина не смогла найти какой-то из классов
	java.lang.VerifyError - класс найден, но с ним что-то не так с байт-кодом
- Exeption - ошибки уровня программы: некорректные параметры, состояние. Могут быть проверяемые (**checked**) и непроверяемые (**unchecked**)

### Класс Throwable
Родитель всех классов исключений.
Методы класса **throwable**:

Из **stacktrace** можно получить пакет, имя класса и полный путь методов, в котором произошла ошибка.
### Проверяемые исключения
Exception и его подклассы (кроме RuntimeEx) - проверяемые исключения. Проверяемые исключения - отслеживаются компилятором, должны быть обязательно обработаны или быть выброшены методом
	Пример:
	**IOException** - ошибка ввода вывода
	**SQL Exception** - ошибка при выполнении SQL запросов
	**ClassNotFoundException** - возникает при попытке загрузить класс, которого не существует
	**InterruptedException** - ошибка, которая выбрасывается при прерывании потока

Если исключения не обрабатывается, то надо прописать throws у всех методов, вызывающих наш метод.

### Непроверяемые исключения
RuntimeEx и его подклассы - непроверяемые. Можно бросать, не декларируя в **сигнатуре метода и в вызывающих методах** (throws)
	**java.lang.NullPointerException**
	**java.lang.ArrayIndexOfBoundsException**
	**java.lang.ArithmeticException**
	**ClassCastException**
Обрабатывать можно, но делать этого не стоит. Разработчику не предоставлены инструменты для обработки ошибок системы и виртуальной машины.

## Создать свой тип исключения
```java
public class DogIsNotReadyException extends Exception { 
	public DogIsNotReadyException(String message) {
		super(message);
	} 
}
```
Наследуемся от Ex или RuntimeEx.
## Как выбросить исключение
"test" - сообщение, поясняющее проблему, будет напечатано вместе со Stacktrace
```java
Exception a = new Exception("test");  
throw a;
```
Или
```java
throw new Exception("test");
```
Т.о. можно выбросить не новое исключение
#### Оператор throws
Иногда метод, в котором может генерироваться исключение, сам не обрабатывает это исключение. В этом случае в объявлении метода используется оператор **throws**, который надо обработать при вызове этого метода. Например, у нас имеется метод вычисления факториала, и нам надо обработать ситуацию, если в метод передается число меньше 1:
```java
public static int getFactorial(int num) throws Exception{
    if(num<1) throw new Exception("The number is less than 1");
    int result=1;
    for(int i=1; i<=num;i++){
        result*=i;
    }
    return result;
}
```
### Подавленные исключения
[Подавленные исключения Java - javascopes.com](https://javascopes.com/java-suppressed-exceptions-034708da/)
Когда мы ловим исключение и никак его не обрабатываем.
`catch (Exception ex) {}` Игнорируемое исключение.

Подавленное исключение - это то, которое игнорируется каким-либо образом.
Когда исключение запустило цепочку исключений. Чтобы найти первоисточник, надо использовать метод getsupressed

## Конструкции обработки исключений
### try catch finally
![[try catch finally.png]]
В языке Java предусмотрены специальные средства для обработки подобных ситуаций. Одним из таких средств является конструкция **try...catch...finally**. При возникновении исключения в блоке **try** управление переходит в блок **catch**, который может обработать данное исключение. Если такого блока не найдено, то пользователю отображается сообщение о необработанном исключении, а дальнейшее выполнение программы останавливается. Блок **finally** является не обязательным.  Блок **finally** выполняется в любом случае, возникло ли исключение в блоке try или нет

```java
public class Main {  
    public static void main(String[] args) {  
        try {  
            int[] numbers = new int[3];  
            numbers[4] = 45;  
            System.out.println(numbers[4]);  
        } catch (Exception ex) {  
            ex.printStackTrace();  
        }  
        System.out.println("Программа завершена");  
    }  
}
```
**Finaly** отработает даже если:
- в **try** будут **break**
- в **try** будут **return**
- исключение из **try** обработано блоком **catch**
- исключение из **try** не поймано ни одним блоком **catch**
- блоком **catch** выброшено новое исключение
finally не выполнится с System.exit(0) или если во время try виртуальная машина легла.
![[Особые случаи когда finally не выполняется.png]]

> [!NOTE]
Если в **finaly** и в **try** вылетело исключение, то исходное исключение из **try** будет потеряно. Поэтому можно встретить блок **try - catch** внутри блока **finally**

### Try-finally конструкция
[Java: try + finally | Programming.Guide](https://programming.guide/java/try-finally.html)

> [!NOTE]
> **Try** требует наличие либо **catch**, либо **finally**
### try with resourses
[Урок Java 166 Try с ресурсами и AutoClosable - YouTube](https://www.youtube.com/watch?v=aHO60SmsfJA)
Конструкция появилась с java 7
Когда мы открываем файл, то для нормальной работы он должен быть закрыт.
Блок try with resourses автоматически закрывает ресурсы (файлы и т.д.). Было исключение или нет

Ресурсы - любые объекты, реализующие интерфейс AutoClosable

**Конструкция**:
try (ресурс1; ресурс2) {}

**Здесь исключение из *close* не перебьет собой исходное исключение**, а будет добавлено в него в качестве заглушенного (supressed)
![[Особенность try with resourse.png]]
## Особенности catch блоков
Блок **catch** видит то, что было перед блоком **try**. Он не видит то, что объявлено в самом **try**
Если исключение не вылетело, то блок **catch** не исполняется.
### В каком порядке следует обрабатывать исключения в catch блоках?
[Исключения в Java: catch под лупой. Часть 3 / Skillbox Media](https://skillbox.ru/media/base/isklyucheniya-v-java-catch-pod-lupoy-chast-3/)
Catch блоки должны идти в порядке иерархии **наследник -> родитель**
Иначе все исключения будет принимать первый блок catch, например класса Exception e
### Поймать несколько исключений
Для того, чтобы не дублировать код с Java 7 ввели возможность ловить сразу несколько исключений в блоке catch
Это называется **multi-catch** — многократный перехват. В нём можно перечислить несколько исключений, разделив их знаком `|`
```java
try {
    //Здесь какой-то код
} catch (ArithmeticException | NullPointerException e) {
    System.out.println("Единый код на случай ArithmeticException и NPE");
} catch (Exception e) {
    System.out.println("Что-то пошло не так. Но это точно не ArithmeticException и не NPE.");
} finally {
    System.out.println("А напоследок я скажу...");
}
```

## Вопросы
### Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?
Может и оно будет передано в виртуальную машину Java (JVM).
Для случая с методом main произойдет две вещи:
- будет завершен главный поток приложения
- будет вызван **ThreadGroup.uncaughtException**
