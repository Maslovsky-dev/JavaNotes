---
tags: ORM 
---
**Hibernate** — библиотека для языка программирования Java, предназначенная для решения задач объектно-реляционного отображения ([ORM](https://ru.wikipedia.org/wiki/ORM "ORM")), самая популярная реализация спецификации [JPA](https://ru.wikipedia.org/wiki/Java_Persistence_API "Java Persistence API")
## Классы и интерфейсы

| Интерфейс          | Описание                                                                                                                                                                                                                                                                                                                                       |
|--------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [[Session]]            | Интерфейс Session является основным инструментом, используемым для связи с Hibernate. Он предоставляет API, позволяющий создавать, читать, обновлять и удалять постоянные объекты. Сессия имеет простой жизненный цикл. Открываем, выполняем какие-то операции, а потом закрываем.                                                             |
| SessionFactory     | SessionFactory — это интерфейс, который присутствует в **org.hibernate**, используется для создания объекта сеанса. Он неизменяем и поточно-безопасен по своей природе.                                                                                                                                                                           |
| Configuration      | Интерфейс используется для настройки и начальной загрузки hibernate. Экземпляр этого интерфейса используется приложением для указания местоположения документов сопоставления, относящихся к hibernate.                                                                                                                              |
| Transaction        | Определяет единицу работы (транзакцию). Он поддерживает абстракцию от реализации транзакции (JTA, JDBC). Транзакция связана с сеансом и создается путем вызова сеанса.                                                                                                                                                                         |
| Query and [[Criteria API]]| Это объектно-ориентированное представление Hibernate Query. Объект Query можно получить, вызвав интерфейс сеанса метода createQuery(). Интерфейс запроса предоставляет множество методов. Интерфейс Criteria предоставляет методы для применения критериев, таких как получение всех записей таблицы, зарплата которых превышает 50000 и т. д. |

![[Последовательность взаимодействия интерфейсов hibernate.png]]
[[EntityManager]]
## Основные аннотации Hibernate
 [[Основные аннотации Hibernate]]

[[Генерация первичных ключей Hibernate]]

## Отличие HQL от SQL
[HQL](https://java-online.ru/hibernate-hql.xhtml) (Hibernate Query Language) - это объекто-ориентированный язык запросов, который очень похж на SQL. Главное различие языков HQL и SQL связано с тем, что SQL формирует запросы из наименований таблиц в базе данных и их столбцов, а HQL работает с сущностями (классами) и их полями (аттрибутами класса).

Query - класс, который принимает данные из таблицы. Также можно передать параметры в запрос с помощью Query.
```java
String hql = "FROM User where name = :paramName";
Query query = session.createQuery(hql);
query.setParameter("paramName", "Alex");
List<User> users = query.list();
```

## Автоматическое создание схемы данных
Параметр `hbm2ddl.auto`. У нее может быть 5 различных значений:
**validate**
Валидация: Hibernate проверит, совпадают ли имена и типа колонок и полей в базе и в аннотациях. Это самый частый режим.
**update**
Апдейт: Hibernate обновит таблицы в базе, если они или их колонки отличаются от ожидаемых.
**create**
Пересоздание: Hibernate удалит все таблицы в базе и создаст их заново на основе данных из аннотаций.
**create-drop**
Создание-удаление. В начале работы Hibernate создаст все таблицы, в конце работы – удалит их за собой.
**none**
Hibernate вообще ничего не будет делать. Если где-то база не совпадает с ожиданием, то будут сыпаться ошибки во время выполнения запросов.
https://javarush.com/quests/lectures/questhibernate.level09.lecture04
## Entity
[[Каким условиям должен удовлетворять класс чтобы являться Entity|Entity]]
[[Жизненный цикл Entity в Hibernate]]

## Связи
[[Связи таблиц]]
[[Встраиваемый класс Embeddable]]
## Маппинг Hibernate
[[Маппинг Hibernate]]

## Типы загрузки данных
[[Fetch type Hibernate]]
## Каскады
[[Каскадные обновления]]

## Под капотом
### PROXY
Proxy используется для замены реальной сущности POJO (Plain Old Java Object).
![[Класс proxy.png]]
**Паттерн Заместитель (Proxy)** предоставляет объект-заместитель, который управляет доступом к другому объекту. То есть создается объект-суррогат, который может выступать в роли другого объекта и замещать его (перехватывать все вызовы). [[Паттерны#PROXY]]

Hibernate использует объекты Proxy для объектов, чтобы разрешить отложенную LAZY загрузку:
`@ManyToMany(optional = false, fetch = FetchType.LAZY)`

>[!Note]+ Ленивая загрузка
>Зачем нужна ленивая загрузка? Вы загружаете большую часть своей базы данных, просто загружая один объектCompany. Это приведет к проблемам с памятью. Поэтому Hibernate **загружает только первый объект** и заменяет наборы других объектов прокси. Если вы обращаетесь к прокси-серверу, Hibernate использует текущую сессию для инициализации прокси-сервера и загрузки записей из базы данных.

PROXY cоздаётся динамически во время компиляции. При доступе к основным свойствам он просто делегирует вызов исходной сущности.
![[ProxyTest.png]]

Hibernate может использовать разные библиотеки для создания PROXY:
- ByteBuddy (используется в примере выше) - по умолчанию
- Javaassist (заменил cglib, но все еще есть в исходниках)
- Сglib (использовался в первых версиях Hibernate)

>[!note]+ Proxy и коллекции
>Каждый **List, Set, Map** тип в классе сущностей замещен **PersistentList, PersistentSet, PersistentMap**. Эти классы отвечают за перехват вызова неинициализированной коллекции.
>
>Прокси не выдает никаких операторов SQL. Он просто запускает **InitializeCollectionEvent**, который обрабатывается связанным прослушивателем, который знает, какой запрос инициализации выпустить (зависит от настроенного плана выборки).
>
>Proxy объект получаем через метод **session.load()**, если вызываем геттеры и сеттеры, то выполняется SELECT в базу на получение реального объекта.

## Кэширование hibernate
 [[Кэширование hibernate]]

## Проблема N+1 Select
[[Проблема N plus 1 Select Hibernate]]
