---
tags: ORM
---
Entity – это легковесный хранимый объект бизнес-логики (persistent domain object).
Основная программная сущность – это entity класс, который так же может использовать дополнительные классы, как вспомогательные или для сохранения состояния еntity.

Entity Class – это Java класс, который отображает информацию таблицы в базе данных.
Это также POJO класс, в котором используются Hibernate аннотации для связи класса с
таблицей из базы данных.

**Персистентное поле** – это поле сущности, которое отражается в БД в виде столбца
таблицы.

**Персистентное свойство** – это методы, поведение сущности, которые аннотированы вместо полей для доступа провайдера к ним (полям).

Эти поля или свойства используют аннотации объектно- реляционного сопоставления (маппинга) для сопоставления сущностей и отношений между ними с реляционными данными в хранилище данных.

Есть два вида доступа к состоянию сущности:
**Доступ по полю**, когда аннотации стоят над полями.
В этом случае провайдер, например, Hibernate, обращается к полям класса напрямую, используя Reflection.
**Доступ по свойству** (методу), когда аннотации стоят над методами-геттерами. В этом случае провайдер, например, Hibernate, обращается к полям класса через методы.

## Требования JPA к классам Entity
![[Требования JPA к Entity классам.png]]
## Требования Hibernate к классам Entity
Требования к Entity классу в Hibernate МЯГЧЕ, т.е. Hibernate не так строг.
Отличия от JPA:

Класс сущности должен иметь конструктор без аргументов, который может быть не только public или protected, но и package visibility (default), т.е. любой модификатор
- Класс сущности не обязательно должен быть классом верхнего уровня, т.е. может
быть вложенным классом
- Технически Hibernate может сохранять финальные классы или классы с финальными методами (getter / setter). Однако, как правило, это не очень хорошая идея, так как это лишит Hibernate возможности генерировать прокси для отложенной загрузки сущности. Т.к. final class не может иметь наследников, то => Hibernate не сможет создавать PROXY объекты для LAZY загрузки.
- Hibernate не запрещает разработчику приложения открывать прямой доступ к переменным экземпляра и ссылаться на них извне класса сущности, однако обоснованность такого подхода спорна.

## Может ли АК быть Entity
Абстрактный класс может быть Entity классом. Абстрактный Entity класс отличается от обычных Entity классов только тем, что нельзя создать объект этого класса.

Имена абстрактных классов могут использоваться в запросах.

Абстрактные Entity классы используются в наследовании, когда их потомки наследуют поля абстрактного класса:
![[АК Entity.png]]

## Наследование Entity
![[Наследование Entity общая схема.png]]
## Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?

Да, сущности могут наследоваться от НЕ Entity классов, которые, в свою очередь, могут быть как абстрактными, так и обычными.

>[!Note]
> Состояние (поля) НЕ Entity суперкласса НЕ является персистентным, то есть не хранится в БД и не обрабатывается провайдером (Hibernate), поэтому любое такое состояние (поля), унаследованное Entity классом, также НЕ будет отображаться в БД.
>

![[Наследование Entity.png]]

Не Entity суперклассы не могут участвовать в операциях EntityManager или Query.
Любые маппинги или аннотации отношений в не Entity суперклассах игнорируются.
## Может ли Entity класс наследоваться от других Entity классов?
Да, может
## Может ли не Entity класс наследоваться от Entity класса?
Да, может

## Что такое Mapped Superclass
Это стратегия наследования полей, когда базовый класс **не является отдельной Entity** сущностью Hibernate и **не имеет своей таблицы в базе данных**.
![[Mapped superclass.png]]

**Mapped Superclass** (сопоставленный суперкласс) – это класс, от которого наследуются Entity, он может содержать аннотации JPA, однако сам такой класс **не является Entity**, ему не обязательно выполнять все требования, установленные для Entity (например, он может не содержать первичного ключа).

>[!note]
>Эти суперклассы чаще всего используются, когда есть общая для нескольких классов сущностей информация о состоянии и отображении, которую можно вынести в Mapped Superclass.

### Особенности Mapped SuperClass
- Должен быть помечен аннотацией @MappedSuperclass или описан в xml файле.
- Не может использоваться в операциях EntityManager или Query, вместо этого нужно использовать классы-наследники.
- Не может состоять в отношениях с другими сущностями, т.е. в Entity нельзя создать поле с типом сопоставленного суперкласса.
- Может быть абстрактным.
- Не имеет своей таблицы в БД.

Основным недостатком использования сопоставленного суперкласса является то, что полиморфные запросы невозможны, то есть мы не можем загрузить всех наследников Mapped Superclass.

### Сравнение Mapped Superclass v.s. Embeddable class
**Сходства**:
- не являются сущностями и могут иметь все аннотации, кроме @Entity;
- не имеют своих таблиц в БД;
- не могут использоваться в операциях EntityManager или Query.

**Различия**:
- MappedSuperclass – это наследование, а Embeddable class – это композиция (экземпляр «части» может входить только в одно целое (или никуда не входить));
- Поля из Mapped Superclass могут быть у сущности в одном экземпляре, а полей из Embeddable class может быть сколько угодно (встроив в сущность Embeddable class несколько раз и поменяв имена полей);
- В Entity нельзя создать поле с типом сопоставленного суперкласса, а с Embeddable можно и нужно.

## [[Cтратегии маппинга иерархии наследования Inheritance Mapping Strategies в JPA]]
