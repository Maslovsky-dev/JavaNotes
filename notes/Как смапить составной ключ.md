---
tags: ORM
--- 
Составной первичный ключ, также называемый составным ключом, представляет собой комбинацию из двух или более столбцов для формирования первичного ключа таблицы.

**В соответствии с JPA, допустимые типы атрибутов для первичного ключа:** 
- примитивные типы и их обертки 
- строки 
- BigDecimal и BigInteger
- java.util.Date и java.sql.Date

## Подходы к реализации составных ключей

trans## Аннотация `@IdClass`:
С помощью аннотации `@IdClass` вы определяете **класс, который представляет составной ключ**. В этом классе должны быть определены поля, соответствующие полям составного ключа сущности, а также переопределены методы `equals()` и `hashCode()` для правильного сравнения и хэширования объектов ключа.

Пример использования аннотации `@IdClass`:
```java
@Entity
@IdClass(PersonId.class)
public class Person {
    @Id
    private String firstName;

    @Id
    private String lastName;

    // ...
}

public class PersonId implements Serializable {
    private String firstName;
    private String lastName;

    // Переопределение equals() и hashCode()
    // ...
}
```

## Аннотации `@EmbeddedId` и `@Embeddable`
Вы можете определить вложенный класс (embeddable class), который представляет составной ключ сущности. В этом классе должны быть определены поля, соответствующие полям составного ключа, а также переопределены методы `equals()` и `hashCode()`.

Пример использования аннотаций `@EmbeddedId` и `@Embeddable`:
```java
@Entity
public class Person {
    @EmbeddedId
    private PersonId id;

    // ...
}

@Embeddable
public class PersonId implements Serializable {
    private String firstName;
    private String lastName;

    // Переопределение equals() и hashCode()
    // ...
}
```

## Сравнение @IdClass v.s. @EmbeddedId
C аннотацией **@IdClass** пришлось указывать столбцы дважды - в AccountId и в Account.
Но с @EmbeddedId мы этого не сделали; 

JPQL-запросы с @IdClass проще. С @EmbeddedId, чтобы получить доступ к полю, нужно из сущности обратиться к встраиваемому классу и потом к его полю:

![[обращение к полю составного ключа hibernate.png]]
**@EmbeddedId** более подробна, чем @IdClass, поскольку можно получить доступ ко всему объекту первичного ключа, используя метод доступа к полю в классе-сущности.
Это также дает четкое представление о полях, которые являются частью составного ключа, поскольку все они агрегированы в классе, который доступен только через метод доступа к полям; 
@IdClass может быть предпочтительным выбором по сравнению с @EmbeddedId в ситуациях, когда класс составного первичного ключа поступает из другого модуля или устаревшего кода, а также когда невозможно его изменить, например, чтобы установить аннотацию @EmbeddedId. Для таких сценариев, когда нельзя изменить класс составного
ключа, аннотация @IdClass является единственным выходом;

Если нужно получить доступ к частям составного ключа по отдельности, можно использовать @IdClass, но в тех местах, где часто используется полный идентификатор в
качестве объекта, @EmbeddedId предпочтительнее.
## Требования к составному ключу JPA

- составной КЛЮЧ должен быть представлен классом первичного ключа, при этом используется одна из двух аннотаций: **@IdClass** и **@EmbeddedId**; 
- КЛАСС первичного ключа должен быть public и иметь public конструктор без аргументов; 
- КЛАСС первичного ключа должен имплементировать маркерный **интерфейс Serializable**; 
- КЛАСС первичного ключа должен иметь методы **equals и hashCode**; 
- АТРИБУТЫ, представляющие поля составного ключа, могут быть базовыми, составными и @ManyToOne, но НЕ могут быть коллекциями или @OneToOne.

Первое правило имеется только в JPA.

