---
tags: Паттерны
---
Стратегии обработки ошибок: Circuit Breaker pattern (автоматический выключатель, предохранитель)

## Проблема:
есть некоторое приложение, которое содержит множество микросервисов. Все они общаются между собой, один из них получает данные из базы, передает другому, тот в свою очередь обрабатывает их, передает полученный id следующему сервису и так далее по цепочке.

Если в нашем приложении в каком-либо блоке произошла какая-либо ошибка (или БД), один из сервисов, который передает результат по цепочке через другие сервисы отвалился и все стало очень плохо.

## Варианты решения:

1. **Idempotency Key (ключ идемпотентности)**

Каждый наш запрос из сервиса А мы снабжаем ключом, подписываем, говорим сервису B что вот этот запрос наш и у него такой вот идентификатор.

Для параллельной отправки запросов подойдут не все запросы. Мы должны быть уверены, что:

- есть несколько реплик сервиса B, - запрос идемпотентен (то свойство, когда мы можем безопасно переотправлять запрос, т.к. мы получим один и тот же результат). Идемпотентными запросами обладают GET, HEAD, PUT, DELETE. - используем Idempotency key, - требуется какая-либо доработка стороннего сервиса, т.к. может оказаться, что сторонний сервис (или БД) и мы никак не можем на него повлиять. В таком случае потребуется что-либо придумать на клиентской стороне, чтобы уведомить пользователя о данной проблеме.

2. **Переотправка запросов (Retry pattern)** Мы будем переотправлять запрос до тех пор, пока он не окажется успешным.

>[!note]+ Сколько же раз стоит повторять?
> Перед тем как повторять отправку, можно проверить, что это за ошибка. Если пользователь ввел неверные данные карты, то сколько бы мы не пробовали раз повторить, то все равно не получится совершить удачный запрос. Если исчерпали какое-то кол-во попыток, то не стоит пробовать отправлять дальше до бесконечности. Например, такую ошибку можно сразу показать. Если возникла ошибка timeout exception или too many request, тогда можем попытаться отправить снова.

Здесь лучше дать серверу некоторое время чтобы он восстановил свою работу (условно 1 – 2 секунды или более) и снова повторить запрос.
![[Стратегии ожидания-1.png]]
## Стратегии ожидания

- без ожидания (no delay), когда сразу без паузы повторяем отправку запроса с константным значением (constant)
- устанавливаем строго заданный лимит с линейным значением (linear)
- с экспоненциальным значением (exponencial)

**В каких случаях стоит использовать Retry паттерн?**

Когда в вашем приложении при работе с удаленным сервисом могут возникнуть временные ошибки. Эти ошибки имеют кратковременный характер и высока вероятность того, что следующие запросы будут завершены успешно (Временная недоступность сервиса или тайм-ауты из-за пиковой нагрузки на сервис).

**Когда не стоит использовать данный паттерн?**

Когда ошибки имеют долговременный характер, и приложение будет бесполезно тратить ресурсы на попытки повторить операции (в этом случае стоит задуматься об использовании Circuit Breaker) Для обработки ошибок связанных с бизнес-логикой приложения Если сервис слишком часто сигнализирует о том, что он “занят”, то скорее всего он требует больше ресурсов

3. Circuit Breaker pattern **(предохранитель)**

**В Spring обычно берут реализацию из Netflix стека, которая называется Hystrix.**

Hystrix **— это библиотека задержек и отказоустойчивости, это реализация паттерна Circuit Breaker.**

Как сказано из официальной документации: Hystrix — это библиотека, которая помогает вам контролировать взаимодействие между этими распределенными сервисами, добавляя терпимость к задержкам и логику отказоустойчивости.

Есть готовое решение для подобного рода проблем:

## Паттерн Circuit Breaker
предотвращает попытки приложения выполнить операцию, которая скорее всего завершится неудачно, что позволяет продолжить работу дальше не тратя важные ресурсы, пока известно, что проблема не устранена. Приложение должно быстро принять сбой операции и обработать его.

Он также позволяет приложению определять, была ли устранена неисправность. Если проблема устранена, приложение может попытаться вызвать операцию снова.

Circuit Breaker выступает как прокси-сервис между приложением и удаленным сервисом. Прокси-сервис мониторит последние возникшие ошибки, для определения, можно ли выполнить операцию или просто сразу вернуть ошибку.

Если на сервисе B что-то пошло не так, то он возвращает сервису А ошибку и запоминает, что там есть ошибки, и просто последующие запросы не отправит на сервис B. Мы не тратим ресурсы сервера в таком случае.

У него есть 3 состояния:

1. Closed: запрос от приложения направляется напрямую к сервису. Счетчик ошибок = 0 и приложение спокойно функционирует и шлет запросы направо и налево. Все счастливы.

Прокси-сервис увеличивает счетчик ошибок, если операция завершилась неуспешно. Если количество ошибок за некоторый промежуток времени превышает заранее заданный порог значений, то прокси-сервис переходит в состояние Open и запускает таймер времени ожидания. Когда таймер истекает, он переходит в состояние Half-Open. Назначение таймера — дать сервису время для решения проблемы, прежде чем разрешить приложению попытаться выполнить операцию еще раз.

2. Open: запрос от приложения немедленно завершается с ошибкой и исключение возвращается в приложение.

3. Half-Open: ограниченному количеству запросов от приложения разрешено обратиться к сервису. Если эти запросы успешны, то считаем что предыдущая ошибка исправлена и прокси-сервис переходит в состояние Closed (счетчик ошибок сбрасывается на 0). Если любой из запросов завершился ошибкой, то считается, что ошибка все еще присутствует, тогда прокси-сервис возвращается в состояние Open и перезапускает таймер, чтобы дать системе дополнительное время на восстановление после сбоя.


Состояние Half-Open помогает предотвратить быстрый рост запросов к сервису. Т.к. после начала работы сервиса, некоторое время он может быть способен обрабатывать ограниченное число запросов до полного восстановления.

Шаблон Circuit Breaker обеспечивает стабильность, пока система восстанавливается после сбоя и снижает влияние на производительность.

Благодаря этому можно поддерживать определенный показатель времени отклика системы, быстро отклоняя запрос на операцию, которая, скорее всего, завершится со сбоем, вместо того чтобы ждать, пока не истечет время ожидания операции или ждать в течение неопределенного времени (так как операция никогда не возвратится).

Схематично работа паттерна Circuit Breaker выглядит подобным образом.
![[Circuit Breaker схема-1.png]]
Возьмем пример с оплатой картой:

Проверяем, в каком состоянии circuit breaker если закрыт (Closed), то отправляем запрос на сервер, делаем попытку оплаты, все хорошо и все счастливы если произошла ошибка, то переводим в состояние Open, запускаем таймер, и показываем ошибку. Следующий раз, когда будем слать запрос, состояние уже не Closed, а Open, то мы проверяем тот самый таймер (таймер — это то время, которое мы даем серверу на восстановление). Если он не истек, т.е. эта условная скажем минута еще не прошла, то мы на клиенте завершаемся с ошибкой, которая была в предыдущем запросе. Если таймер истек — пробуем оплатить, все хорошо — переводим в состояние Closed, выключаем таймер и завершаем оплату заказа. Если все плохо — то возвращаемся на шаг Open.

## Когда стоит использовать?

Для предотвращения попыток обращения к сервису или разделяемым ресурсам, когда **вероятность возникновения ошибки высока** и эти **ошибки имеют продолжительный характер.**

**Когда не стоит использовать?**

Для обращения к приватным ресурсам приложения — это даст только дополнительный overhead

Как замена обработки исключений бизнес-логики приложения
