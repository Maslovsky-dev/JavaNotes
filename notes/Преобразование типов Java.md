---
aliases: приведение типов, явное преобразование
tags: Java/ОсновыЯзыка
--- 
## Явные и неявные преобразования
Когда в одной операции вовлечены данные разных типов, не всегда необходимо использовать операцию преобразования типов. Некоторые виды преобразований выполняются неявно, автоматически.

### Автоматические преобразования
![Приведение типов](https://developer.alexanderklimov.ru/android/java/cast.png)

Сплошные линии обозначают преобразования, выполняемые без потери данных. Штриховые линии говорят о том, что при преобразовании может произойти потеря точности.

Расширяющие автоматические преобразования представлены следующими цепочками:

**byte -> short -> int -> long**

**int -> double**

**short -> float -> double**

**char -> int**

### Автоматические преобразования с потерей точности
Некоторые преобразования могут производиться автоматически между типами данных одинаковой разрядности или даже от типа данных с большей разрядностью к типа с меньшей разрядностью. Это следующие цепочки преобразований: **int -> float**, **long -> float** и b. Они производятся без ошибок, но при преобразовании мы можем столкнуться с потерей информации.

Например:

``` Java
int a = 2147483647;
float b = a;            // от типа int к типу float
System.out.println(b);  // 2.14748365E9
```

### Явные преобразования
Во всех остальных преобразованиях примитивных типов явным образом применяется операция преобразования типов. Обычно это сужающие преобразования (narrowing) от типа с большей разрядностью к типу с меньшей разрядностью:

```java
long a = 4;
int b = (int) a;
```

### Потеря данных при преобразовании
При применении явных преобразований мы можем столкнуться с потерей данных. Например, в следующем коде у нас не возникнет никаких проблем:

``` Java
int a = 5;
byte b = (byte) a;
System.out.println(b);      // 5
```
Число 5 вполне укладывается в диапазон значений типа byte, поэтому после преобразования переменная b будет равна 5. Но что будет в следующем случае:

``` java
int a = 258;
byte b = (byte) a;
System.out.println(b);      // 2
```
Результатом будет число 2. В данном случае число 258 вне диапазона для типа byte (от -128 до 127), поэтому произойдет усечение значения. Почему результатом будет именно число 2?

Число a, которое равно 258, в двоичном системе будет равно 00000000 00000000 00000001 00000010. Значения типа byte занимают в памяти только 8 бит. Поэтому двоичное представление числа int усекается до 8 правых разрядов, то есть 00000010, что в десятичной системе дает число 2.

## Усечение рациональных чисел до целых
При преобразовании значений с плавающей точкой к целочисленным значениям, происходит усечение дробной части:


``` java
double a = 56.9898;
int b = (int)a;
```

Здесь значение числа b будет равно 56, несмотря на то, что число 57 было бы ближе к 56.9898. Чтобы избежать подобных казусов, надо применять функцию округления, которая есть в математической библиотеке Java:

``` java
double a = 56.9898;
int b = (int)Math.round(a);
```
