---
tags: Java/Обобщения
---
Простой список элементов проиндексированный целыми числами от 0 до (размер - 1 элемента)

Лист предоставляет доступ к элементам по их индексу

Один и тот же элемент может встречаться в списке несколько раз

Метод **subList** возвращает часть списка, в виде отдельного экземпляра List. Важно, что изменения одного списка будут видны в другом. Этот метод позволяет
- Удалять элементы (от индекса и до индекса)
- Искать элементов в части списка

### ListIterator
Помимо проверки наличия следующего элемента в ListIterator также присутствует метод проверки предыдущего элемента (получение предыдущего элемента)
![[ListIterator Img.png|400]]

## ArrayList
**ArrayList** – это динамический массив, т.е. может менять свой размер во время исполнения программы, при этом не обязательно указывать размерность при создании объекта. Элементы ArrayList могут быть абсолютно любых типов в том числе и null.

Используем тогда, когда нам нужна структура, похожая на массив, но где нам нужно добавлять/удалять/изменять элементы. Получение и изменение элементов выполняется быстро, поскольку эти операции просто обращаются к соответствующему элементу массива». В основе ArrayList лежит массив Object (элементами явл. Объекты типа Object).

Ёмкость **capacity** массива по дефолту – 10 мест (не путать размер и ёмкость).

>[!tip]+ Емкость
>Размер массива – это сколько по факту лежит элементов в массиве, а ёмкость – это потенциально возможное кол-во мест).

![[ArrayList summary img.png]]
## Алгоритм основных операций ArrayList
Если вызывается конструктор без параметров, то по умолчанию будет создан массив из 10-ти элементов типа Object (с приведением к типу, разумеется), индексы от 0 до 9.
`elementData = (E[]) new Object[10];`
Можно использовать конструктор `ArrayList(capacity)` и указать свою начальную емкость.
### Добавление элементов list.add("0");
Внутри метода **add(value)** происходят следующие вещи:
- проверяется, достаточно ли места в массиве для вставки нового элемента
`ensureCapacity(size + 1);`
- добавляется элемент в конец (согласно значению size) массива
`elementData[size++] = element;`
Если места в массиве недостаточно, новая емкость рассчитывается по формуле **(oldCapacity * 3) / 2 + 1.**
![[Добавление элементов в ArrayList.png|500]]
Второй момент — это копирование элементов.
Оно осуществляется с помощью нативного метода **System.arraycopy()**, который написан не на языке Java.
![[Img System.arrayCopy.png]]
### Добавление в середину списка list.add(5,"100")
- проверяется, достаточно ли места в массиве для вставки нового элемента
`ensureCapacity(size+1);`
- подготавливается место для нового элемента с помощью **System.arraycopy()**; Все что правее **index** передвигается на 1 позицию вправо
`System.arraycopy(elementData, index, elementData, index + 1, size - index);`
- перезаписывается значение у элемента с указанным индексом
`elementData[index] = element; size++;`
>[!tip]+ Вставка элемента по индексу, когда нет свободных мест
>В случаях, когда происходит вставка элемента по индексу и при этом в вашем массиве нет свободных мест, то вызов **System.arraycopy()** случится дважды: первый в **ensureCapacity()**, второй в самом методе **add(index, value)**, что явно скажется на скорости всей операции добавления.
>
В случаях, когда в исходный список необходимо добавить другую коллекцию, да еще и в «середину», стоит использовать метод **addAll(index, Collection)**. И хотя, данный метод скорее всего вызовет **System.arraycopy()** три раза, в итоге это будет гораздо быстрее поэлементного добавления.
### Удаление элементов
Удалять элементы можно двумя способами:
- по индексу **remove(index)**
- по значению **remove(value)**
- Сначала определяется, какое количество элементов надо скопировать
`int numMoved = size - index - 1;`
- затем копируем элементы используя System.arraycopy()
`System.arraycopy(elementData, index + 1, elementData, index, numMoved);`
- уменьшаем размер массива и забываем про последний элемент
`elementData[--size] = null; // Let gc do its work`

При удалении по значению, в цикле просматриваются все элементы списка, до тех пор, пока не будет найдено соответствие. Удален будет лишь первый найденный элемент.

При удалении элементов текущая величина **capacity** не уменьшается, что может привести к своеобразным утечкам памяти. Поэтому не стоит пренебрегать методом **trimToSize()**.

## LinkedList
**LinkedList** – список связанных элементов, каждый из которых хранит ссылки на следующий и предыдущий элементы в списке, цепочке. Бывает односвязный и двусвязный списки.

**ВАЖНО!** В каком порядке элементы добавлены, в таком они и находятся.

**LinkedList** — класс, реализующий два интерфейса — List и Deque.
Это обеспечивает возможность создания двунаправленной очереди из любых (в том числе и null) элементов. Каждый объект, помещенный в связанный список, является узлом/нодом. Каждый узел содержит элемент, ссылку на предыдущий и следующий узел. Фактически связанный список состоит из последовательности узлов, каждый из которых предназначен для хранения объекта определенного при создании типа.
![[LinkedList Img.png]]
### Алгоритм основных операций
#### Создание связанного списка
`LinkedList<Integer> numbers = new LinkedList<>();`
Данный код создает объект класса **LinkedList** и сохраняет его в ссылке numbers. Созданный объект предназначен для хранения целых чисел (**Integer**). Пока этот объект пуст. Класс LinkedList **содержит** три поля
![[Поля пустого LinkedList.png|200]]
#### Добавление объекта в конец списка
Данный код (numbers.add(8)) добавляет число 8 в конец ранее созданного списка. Под «капотом» этот метод вызывает ряд других методов, обеспечивающих
1) создание объекта типа **Integer**
2) создание нового узла,
3) установку объекта класса Integer в поле item этого узла
4) добавление узла в конец списка и установку ссылок на соседние узлы.
![[Class Node LinkedList Img.png]]
Для установки ссылок на предыдущий и следующий элементы **LinkedList** использует объекты своего вложенного класса **Node**.

При каждом добавлении объекта в список создается один новый узел, а также изменяются значения полей связанного списка (size, first, last).

В случае с добавлением первого элемента создается узел, у которого предыдущий и следующий элементы отсутствуют, т.е. являются null, размер коллекции увеличивается на 1, а созданный узел устанавливается как первый и последний элемент коллекции.

>[!tip]+ Добавление еще одного элемента
>Добавим еще один элемент в нашу коллекцию: numbers.add(5)
Сначала создается узел для нового элемента (число 5) и устанавливается ссылка на существующий элемент (узел с числом 8) коллекции как на предыдущий, а следующим элементом у созданного узла остается null.
>
>Также этот новый узел сохраняется в переменную связанного списка last. Как можно увидеть на рис. 4, первый элемент коллекции (под индексом 0) пока ссылается на null как на следующий элемент. Теперь эта ссылка заменяется и первый элемент начинает ссылаться на второй элемент коллекции (под индексом 1), а также увеличивается размер коллекции:
![[Добавление еще одного элемента LinkedList.png]]

### Добавление элемента в середину списка numbers.add(1, 13).
Как и метод **add(element)**, данный метод вызывает несколько других методов.

1) Осуществляется проверка значения index, которое должно быть положительным числом, меньшим или равным размеру списка.
	- Если index не удовлетворит этим условиям, то будет сгенерировано исключение **IndexOutOfBoundsException**.
	- Если index равен размеру коллекции, то осуществляются действия, описанные предыдущем пункте, так как фактически необходимо вставить элемент в конец существующего списка.
2) Если же index не равен size списка, то осуществляется вставка перед элементом, который до этой вставки имеет заданный индекс.
Для начала с помощью метода node(index) определяется узел, находящийся в данный момент под индексом, под который нам необходимо вставить новый узел. Поиск этого узла осуществляется с помощью простого цикла for по половине списка (в зависимости от значения индекса — либо с начала до элемента, либо с конца до элемента).

Далее создается узел для нового элемента (число 13), ссылка на предыдущий элемент устанавливается на узел, в котором элементом является число 8. Ссылка на следующий элемент устанавливается на узел, в котором элементом является число 5. Ссылки ранее существующих узлов пока не изменены (рис. 6).
![[Вставка элемента в середину LinkedList.png]]
Теперь последовательно заменяются ссылки: для элемента, следующего за новым элементом, заменяется ссылка на предыдущий элемент (теперь она указывает на узел со значением 13), для предшествующего новому элементу заменяется ссылка на следующий элемент (теперь она указывает на узел со значением 5).
И в последнюю очередь увеличивается размер списка (рис. 7).
### Удаление из связанного списка
Для удаления одного элемента из списка класс LinkedList предлагает нам аж 10 методов, различающихся по типу возвращаемого значения, наличию или отсутствию выбрасываемых исключений, а также способу указания, какой именно элемент следует удалить:
![[Методы удаление объекта LinkedList.png]]
Что же происходит при вызове метода **remove(object)?**

Сначала искомый объект сравнивается по порядку со всеми элементами, сохраненными в узлах списка, начиная с нулевого узла. Когда найден узел, элемент которого равен искомому объекту, первым делом элемент сохраняется в отдельной переменной. Потом переопределяются ссылки соседних узлов так, чтобы они указывали друг на друга (рис. 9)
![[Удаление объекта LinkedList.png]]
### Почему LinkedList реализует List и Deque интерфейсы?
Это обеспечивает возможность создания двунаправленной очереди из любых (в том числе и null) элементов. Каждый объект, помещенный в связанный список, является узлом/нодом. Каждый узел содержит элемент, ссылку на предыдущий и следующий узел. Фактически связанный список состоит из последовательности узлов, каждый из которых предназначен для хранения объекта определенного при создании типа.
## ArrayList and LinkedList
>[!NOTE]+ Интерфейсная ссылка
>Объявляем переменную общим интерфейсом, конкретный класс указываем при создании экземпляра. Так можно в дальнейшем заменить реализацию

![[ArrayList и LinkedList.png]]
ArrayList и LinkedList

| Характеристики       | ArrayList | LinkedList |
| -------------------- | --------- | ---------- |
| Доступ по индексу    | дешевый   | дорогой    |
| Добавление элементов | дорогой   | дешевый           |

1. Односвязный список, где каждый элемент ссылается только на один следующий. У последнего нет ссылки.
2. Двусвязный - список, где каждый элемент ссылается на следующий и предыдущий. Первый и последний не имеют ссылок на предыдущий и следующий.
![[Сравнение ArrayList и LinkedList.png]]
### Оцените количество памяти на хранение одного примитива типа byte в LinkedList?
Каждый элемент LinkedList хранит ссылку на предыдущий элемент, следующий элемент и ссылку на данные.
```java
private static class Node<E> { // 8 байт 
	E item;                         // 4 байта 
	Node<E> next;                   // 4 байта 
	Node<E> prev;                   // 4 байта
}   
```
Итого 24 байта (кратно 8) для хранения элемента в списке. Плюс 16 байт для хранения упакованного объекта Byte (8 байт заголовок и 8 байт для значений из пула int).
Итого 40 байт для 32-битной JVM Итого 64 байта для 64-битной JVM

Для 32-битных систем каждая ссылка занимает 32 бита (4 байта). Сам объект (заголовок) вложенного класса Node занимает 8 байт. 4*3 + 8 = 20 байт, а т.к. размер каждого объекта в Java кратен 8, соответственно получаем 24 байта.
Примитив типа byte занимает 1 байт памяти, но в JCF примитивы упаковываются: объект типа Byte занимает в памяти 16 байт (8 байт на заголовок объекта, 1 байт на поле типа byte и 7 байт для кратности 8). Значения от -128 до 127 кэшируются в пул int и для них новые объекты каждый раз не создаются. Таким образом, в x32 JVM 24 байта тратятся на хранение одного элемента в списке и 16 байт - на хранение упакованного объекта типа Byte. Итого 40 байт.

Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт), размер заголовка каждого объекта составляет 16 байт (два машинных слова). Вычисления аналогичны: 8*3 + 16 = 40 байт и 24 байта. Итого 64 байта.

### Оцените количество памяти на хранение одного примитива типа byte в ArrayList
ArrayList основан на массиве, для примитивных типов данных осуществляется автоматическая упаковка значения, поэтому 16 байт тратится на хранение упакованного объекта и 4 байта (8 для x64) на хранение ссылки на этот объект в самой структуре данных.
Таким образом, в x32 JVM 4 байта используются на хранение одного элемента и 16 байт на хранение упакованного объекта типа Byte. Для x64 - 8 байт и 24 байта соответственно.
## Vector
Устаревшая коллекция. Основное отличие - вектор синхронизированная коллекция (только один поток может одновременно работать с коллекцией)
[Vector vs ArrayList in Java - GeeksforGeeks](https://www.geeksforgeeks.org/vector-vs-arraylist-java/)

### Stack
— это линейная структура данных, которая следует принципу LIFO (последний пришел, первый ушел). Это означает, что объекты могут быть вставлены или удалены только с одного конца, также называемого вершиной.

>[!Example] Стопка тарелок на столе
[![Data stack](https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Data_stack.svg/256px-Data_stack.svg.png)](https://commons.wikimedia.org/wiki/File%3AData_stack.svg "By User:Boivie [Public domain], via Wikimedia Commons")
