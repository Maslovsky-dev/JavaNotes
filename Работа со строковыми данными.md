---
tags: Java/ОсновыЯзыка
---

Строка относится к ссылочному типу данных.

Для создания новой строки мы можем использовать один из конструкторов класса String, либо напрямую присвоить строку в двойных кавычках:
```Java
public class Main {  
    public static void main(String[] args) {  
  
        String str1 = "Java";  
        String str2 = new String(); // пустая строка  
        String str3 = new String(new char[]{'h', 'e', 'l', 'l', 'o'});  
        String str4 = new String(new char[]{'w', 'e', 'l', 'c'}, 0, 3);//1 -начальный индекс, 3 -кол-во символов  
  
        System.out.println(str1); // Java  
        System.out.println(str2); //  
        System.out.println(str3); // hello  
        System.out.println(str4); // wel  
    }  
}

System.out.println(str3+" "+str1); // объединение строк "hello Java"
```
## Как реализована неизменяемость строк?

-
    Приватное поле `value`: В классе `String` есть private поле `value`, которое является массивом символов (`char[]`), содержащим фактическое значение строки. Это поле помечено как `final`, что означает, что оно не может быть изменено после инициализации.

- Конструктор: Класс `String` имеет несколько конструкторов, которые инициализируют значение `value`. Когда вы создаете новый объект `String`, конструктор копирует переданную строку или массив символов, чтобы создать новый массив `value`.

- Отсутствие public методов для изменения значения: В классе `String` отсутствуют публичные методы, которые позволяют изменять значение `value`. Методы класса `String`, такие как `concat()`, `substring()`, `replace()` и другие, вместо этого создают и возвращают новые объекты `String` с измененными значениями, не затрагивая исходный объект `String`.

## Основные методы класса String
[[Методы класса String]]
## Пул строк
Пул строк - **это особое место в куче**, куда попадают объекты типа String после их создания. Он выполняет функцию кеша строк. Каждый раз, когда Вы создаёте строку, она попадает в строковый пул. Если же на момент создания новой строки пул уже содержит такое же значение, то вместо создания нового объекта возвращается тот, что уже лежит в пуле. [String Pool в Java. Когда нужно использовать строковый пул… ](https://anver-bogatov.medium.com/string-pool-%D0%B2-java-417d4eefa418)

**Строка попадет в pool**
`String text = “Hello World”;`
	что строки, созданные с помощью литералов (как в данном случае), автоматически сохраняются в пуле строк.
Сначала JVM смотрит в пул, есть ли там такая строка? Если есть, то вернет ссылку из пула.
**Строка не попадет в pool**
`String text = new String(“text”);`
	даже если такая строка уже существует в пуле, новый объект строки будет создан в памяти. Строка `"text"` не будет помещена в пул строк.

Метод `intern()`, позволяет явно добавить строку в пул, если она там еще не существует, либо получить ссылку на строку из пула, если она там уже есть. Это может быть полезным, например, когда вы хотите сравнивать строки по ссылке, а не по содержанию.

Применение метода `intern()`:
```java
String text = new String("text").intern(); // Добавляем строку в пул или получаем ссылку (если строка уже есть)
```

[[Стек и куча в Java]]
## StringBuilder и StringBuffer
**StringBuffer** и StringBuilder напоминают расширяемую строку, которую можно изменять без ущерба для производительности.

Классы похожи, имеют одинаковые конструкторы, методы и т.д. класс **StringBuffer** удобнее использовать в многопоточных приложениях; **StringBuilder** - в однопоточных приложениях.
[StringBuffer и StringBuilder](https://metanit.com/java/tutorial/7.3.php)

## Регулярные выражения Regex
[[Regex]]

## Нюансы String
## Почему String неизменяемый и финализированный класс?
Безопасность и String pool – это основные причины неизменяемости String в Java.

Безопасность объекта неизменяемого класса String обусловлена такими фактами:
- вы можете передавать строку между потоками и не беспокоиться что она будет изменена
- нет проблем с синхронизацией (не нужно синхронизировать операции со String)
- отсутствие утечек памяти
- в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д. Неизменяемость позволяет избежать проблем с доступом.
- возможность кэшировать hash code
String pool позволяет экономить память и НЕ создавать новые объекты для каждой повторяющийся строки. В случае с изменяемыми строками - изменение одной приводило бы к изменению всех строк одинакового содержания.
## Почему строки не рекомендуется использовать для хранения паролей
Строка неизменяемая в Java и хранится в пуле строк. С тех пор, как она была создана, она остается в пуле, пока не будет удалена сборщиком мусора, поэтому, когда мы думаем, что закончили работу с паролем, **НО объект остается доступным в памяти** некоторое время, и нет способа избежать этого. Это риск безопасности, поскольку кто- либо, имеющий доступ к дампу памяти сможет найти пароль в виде чистого текста.

Если мы используем массив символов для хранения пароля, мы можем очистить его после того, как закончим с ним работать. Таким образом, мы можем контролировать, как долго он находится в памяти, что позволяет избежать риска безопасности,
## Почему строка является популярным ключом в HashMap
У изменяемых объектов хэшкод изначально равен нулю и он таков до тех пор, пока мы не вызвали метод hash(), тогда и генерируется хэш-значение – в момент получения кода.

Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет необходимости рассчитывать его снова.

Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Это причина, почему строка наиболее часто используемый объект в качестве ключа HashMap.
## Почему не рекомендуется изменять строки в цикле?
Строка является неизменной и финализированной в Java, поэтому все наши манипуляции со строкой всегда будут создавать новую строку.
Манипуляции со строками ресурсоемкие, поэтому Java обеспечивает два полезных класса для манипуляций со строками – StringBuffer и StringBuilder.

## Можно ли использовать строки в конструкции switch
Java 7 расширяет возможности оператора swich для использования строк, ранние версии Java не поддерживают этого.

Если вы реализуете условный поток для строк, вы можете использовать условия if-else и вы можете использовать оператор switch, если используете Java 7 или поздние версии.

Ключевые моменты использования switch для строк в Java. - использование строк в конструкции switch делает код читабельнее, убирая множественные цепи условий if-else
- строки в switch чувствительны к регистру (см. пример)
- оператор switch использует метод String.equals() для сравнения полученного значения со значениями case, поэтому добавьте проверку на NULL во
избежание NullPointerException
- согласно документации Java 7 для строк в switch, компилятор Java формирует более эффективный байткод для строк в конструкции switch, чем для сцепленных условий if-else - убедитесь, что это будет использоваться с Java 7 или поздней версии, иначе получите Exception
