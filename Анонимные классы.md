---
tags: Java/ФИ
--- 

## Анонимный класс от интерфейса
Класс у которого нет имени
```java
// somewhere 
interface SayHello { 
	void say(); 
}

public class Foo { 
// Анонимный класс, который реализует интерфейс SayHello
	static SayHello h = new SayHello() {
		@Override 
		public void say() { 
			System.out.println("Метод внутреннего анонимного класса");
		} 
	}; // ; нужна так как все строчки выше - 1 statement
	public static void main(String[] args) { 
		h.say(); 
	} 
} 

```
Расшифровка:
Какой-то класс, объект которого h, он имплементирует интерфейс SayHello и переопределяет его метод say 

Анонимные классы имеют несколько ограничений: 
- Их использование разрешено только в одном месте программы (месте его создания)
- Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться 
- Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.

Анонимные классы обычно применяются для: 
- создания объекта функции (function object), например реализация интерфейса Comparator; 
- создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных 
- в статическом методе генерации; 
- инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.

**Справка**: В документации Oracle приведена хорошая рекомендация: «Применяйте анонимные классы, если вам нужен
локальный класс для одноразового использования».

Анонимный класс — это полноценный внутренний класс. Поэтому у него есть доступ к переменным внешнего класса, в том числе к статическим и приватным.
## Анонимный класс от класса
1. Как реализация интерфейса (см. выше)
2. Как наследник определенного класса
```java
class Foo {
    public void show() {
        System.out.println("Метод суперкласса");
    }
}

public class External {
    // Анонимный класс наследуется от класса Foo
    static Foo foo = new Foo() {
        @Override
        public void show() {
            super.show();
            System.out.println("Метод внутреннего анонимного класса");
        }
    };
    public static void main(String[] args) {
        foo.show();
    }
}

```
Анонимный класс может быть как статическим, так и нестатическим. Это напрямую зависит от того, статическим или нестатическим является блок, в котором анонимный класс был объявлен.

## Статический анонимный класс
```java
import java.util.function.Consumer;

public class Anonymous {
    public static void main(String[] args) {

        Consumer<String> foo = new Consumer() {
            @Override
            public void accept(Object o) {
                System.out.println(o + " TODO something useful!");
            }
        };

        foo.accept("Работа анонимного класса в статическом методе.");
    }
}
 ```
 То его второй экземпляр можно создать так: Consumer otherInstance = foo.getClass().newInstance(); (эту строку нужно завернуть в try-catch или пробросить исключения выше). И переиспользуем ту же логику, но уже в другом инстансе: otherInstance.accept("Работа второго экземпляра анонимного класса в статическом методе.");.
## Нестатический анонимный класс
Для создания второго экземпляра анонимного класса нужно передать в его конструктор ссылку на обрамляющий класс. В противном случае получим InstantiationException.
```java
public class Anonymous {

    public void nonStaticMethod() {
        // собственно наш анонимный класс
        Consumer<String> foo = new Consumer() {
            @Override
            public void accept(Object o) {
                System.out.println(o + " TODO something useful!");
            }
        };

        foo.accept("Работа анонимного класса в НЕстатическом методе.");

        // достаем конструктор у анонимного класса
        Constructor[] constructors = foo.getClass().getDeclaredConstructors();
        // Записываем ссылку на объект Anonymous в массив параметров, для конструктора.
        Object[] params = new Object[1];
        params[0] = this;

        // Создаем новую ссылку типа Consumer
        Consumer otherInstance = null;
        try {
            // создаем новый экземпляр анонимного класса, передав в его конструктор массив параметров, ссылку на текущий
            // класс, в котором мы и осуществляем все манипуляции с анонимным классом.
            otherInstance = (Consumer) constructors[0].newInstance(params);
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }

        otherInstance.accept("Работа второго экземпляра анонимного класса в НЕстатическом методе.");
    }

    public static void main(String[] args) {
        Anonymous anon = new Anonymous();
        anon.nonStaticMethod();
    }
```

> [!NOTE]
Любой анонимный внутренний класс может за один раз реализовать только один интерфейс. Так же, за один раз можно либо расширить класс, либо реализовать интерфейс, но не одновременно.

## Применение
Анонимные классы полезны в некоторых "узких" участках кода, когда нет необходимости их потом переиспользовать где-то еще. Чаще всего на практике используют лишь один экземпляр анонимного класса. Если же реализацию интерфейса придется использовать много раз в коде — то лучше использовать лямбда-выражения (лямбды), которые стали доступны начиная с JAVA 8.

Например, реализацию интерфейса Consumer, в текущем уроке, можно переписать с помощью лямбд:
```java
import java.util.function.Consumer;

public class Anonymous {

    public static void main(String[] args) {
        Consumer<String> foo = o -> System.out.println(o + " TODO something useful!");
        foo.accept(" Using lambda :)");
    }
}
```
